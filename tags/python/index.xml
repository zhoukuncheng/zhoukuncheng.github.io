<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Python on zhoukuncheng's Personal Blog</title><link>https://zhoukuncheng.github.io/tags/python/</link><description>Recent content in Python on zhoukuncheng's Personal Blog</description><generator>Hugo -- 0.154.3</generator><language>en</language><lastBuildDate>Fri, 19 Apr 2024 00:11:00 +0800</lastBuildDate><atom:link href="https://zhoukuncheng.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Making Vocabulary Memorization Less Boring with LLMs and Telegram Bots</title><link>https://zhoukuncheng.github.io/posts/llm-vocabulary-reminder/</link><pubDate>Fri, 19 Apr 2024 00:11:00 +0800</pubDate><guid>https://zhoukuncheng.github.io/posts/llm-vocabulary-reminder/</guid><description>&lt;h2 id="always-abandoning-english-vocabulary-learning-from-duolingo--to-let-words-remind-you"&gt;Always Abandoning English Vocabulary? Learning from Duolingo ðŸ¦‰ to Let Words Remind You&lt;/h2&gt;
&lt;p&gt;Memorizing vocabulary is inevitable in learning English. From primary school to graduate school, and even in some jobs, you need to remember words.&lt;br&gt;
But gnawing on vocabulary books or rigidly memorizing on a phone is extremely inefficient. Now that LLMs are so popular, why not use them?&lt;br&gt;
After all, the &amp;lsquo;L&amp;rsquo; in LLM stands for Language. LLMs might lack precision in other rigorous tasks, but languages like English are their forte. If technology can solve a problem, don&amp;rsquo;t trouble yourself!&lt;br&gt;
This article shares how to use the Eudic Dictionary API, an LLM, and a Telegram Bot to create an English vocabulary learning assistant, making vocabulary memorization less painful.&lt;br&gt;
Of course, you might find it annoying after a few days, as the inspiration comes from the Duolingo App ðŸ¦‰.&lt;/p&gt;</description></item><item><title>Concurrency Pattern Differences between Python and Go</title><link>https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/</link><pubDate>Mon, 30 Aug 2021 23:54:05 +0800</pubDate><guid>https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/</guid><description>&lt;h2 id="concurrency-in-python"&gt;Concurrency in Python&lt;/h2&gt;
&lt;p&gt;In Python, early concurrency methods were dominated by traditional multi-processing and multi-threading, similar to Java. At the same time, there were many third-party asynchronous solutions (gevent/tornado/twisted, etc.).&lt;br&gt;
In the Python 3 era, the official &lt;code&gt;asyncio&lt;/code&gt; library and &lt;code&gt;async/await&lt;/code&gt; syntax were introduced as Python&amp;rsquo;s official coroutine implementation, which gradually became popular.&lt;/p&gt;
&lt;h3 id="processes"&gt;Processes&lt;/h3&gt;
&lt;p&gt;Example of multi-processing programming:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Process&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The API of &lt;code&gt;multiprocessing&lt;/code&gt; is close to &lt;code&gt;threading&lt;/code&gt;, making it relatively easy to create multi-process programs. It is a solution recommended by Python officially to bypass the GIL restriction of multi-threading.&lt;br&gt;
However, it should be noted that the parameters for creating a process need to be pickle-serializable. It is best to use process-safe data structures like Pipe and Queue (&lt;a href="https://docs.python.org/3/library/multiprocessing.html#programming-guidelines"&gt;Official Programming guidelines&lt;/a&gt;).&lt;/p&gt;</description></item><item><title>Insights on Compiling CPython</title><link>https://zhoukuncheng.github.io/posts/python-build/</link><pubDate>Fri, 24 Jul 2020 01:11:34 +0800</pubDate><guid>https://zhoukuncheng.github.io/posts/python-build/</guid><description>&lt;h2 id="when-do-you-need-to-compile-cpython-yourself"&gt;When Do You Need to Compile CPython Yourself?&lt;/h2&gt;
&lt;p&gt;Most operating systems provide compiled CPython versions. Generally, installing through a package manager is sufficient. However, in some cases, you need to compile CPython yourself to meet specific requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The Python version provided by the OS is too old, and the Python official website or system package repositories do not provide pre-compiled new versions of Python.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pre-compiled versions do not meet performance or extension requirements, for example, compiler optimizations are not enabled, or OpenSSL/SQLite versions do not meet requirements.&lt;/p&gt;</description></item></channel></rss>