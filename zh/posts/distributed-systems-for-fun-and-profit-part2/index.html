<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Distributed Systems for Fun and Profit 笔记（二） | zhoukuncheng's Personal Blog</title><meta name=keywords content="分布式系统"><meta name=description content="2. 抽象的上下不同层次
系统模型
分布式系统中的程序：


在独立节点上同时运行


通过可能引入不确定性和消息丢失的网络连接


并且没有共享内存或共享时钟


系统模型列举了与特定系统设计相关的许多假设，实现分布式系统的环境和设施的假设：

节点具有什么功能以及它们如何失败
通信连接如何运行以及它们如何可能失败
整个系统的属性，例如关于时间和顺序的假设

健壮的系统模型做出最弱假设，强有力的假设创建易于推理的系统模型
此模型中的节点
作为计算和存储的主机：

执行程序的能力
能够将数据存储到内存和稳定持久状态的能力
时钟

节点执行确定性算法
故障模型：崩溃恢复而非拜占庭容错（任意错误）
此模型中的通信连接
通信连接将各个节点相互连接，并任一方向发送消息
网络不可靠，消息易延迟丢失
网络分区：网络断开但节点存活
时间和顺序的假设
信息最多以光速传播
如果距离不同，节点间消息的到达时间、顺序可能不同
同步系统模型
进程以锁定步骤执行；消息传输延迟有已知上限；每个进程都有准确的时钟
异步系统模型
没有时间假设，进程以独立的速率执行；消息传输延迟没有限制；有用的时钟不存在
共识问题
多个节点都同意一些值时达成共识


一致：每个正确节点都同意相同的值


完整：每个正确的进程最多只能决定一个值，如果决定某个值，那么一定是某些进程提议的


终止：所有进程最终达成决定


有效：如果所有正确进程提议相同的值 V，那么所有正确进程决定值 V


两种不可能的结果
FLP 不可能
假定节点只能因崩溃而失效；网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制，
在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法
CAP 定理
三个属性：


（强）一致性：所有节点同时看到相同的数据


可用性：节点故障不会阻止幸存者继续运行


分区容错：网络或节点故障导致消息丢失时，系统仍可继续运行



同时具备这三种属性的系统无法实现：
三种不同的系统类型：

CA（一致性+可用性）：完全严格的仲裁协议，例如两阶段提交
CP（一致性+分区容错）：多数仲裁协议，其中少数分区不可用，例如Paxos
AP（可用性+分区容错）：使用冲突解决方案的协议，例如Dynamo


一致性模型：程序员与系统之间的合同，其中系统保证，如果程序员遵循某些特定规则，则对数据存储区的操作结果将是可预测的

强一致性模型（能够维护单个副本）

Linearizable consistency （可线性化一致性）
Sequential consistency （顺序一致性）


弱一致性

Client-centric consistency models （客户端为中心一致性）
Causal consistency: strongest model available （因果一致性）
Eventual consistency models （最终一致性）



线性化一致性要求操作生效的顺序等于操作的实际实时顺序，顺序一致性允许对操作进行重新排序，只要在每个节点上观察到的顺序保持一致"><meta name=author content="zhoukuncheng"><link rel=canonical href=https://zhoukuncheng.github.io/zh/posts/distributed-systems-for-fun-and-profit-part2/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://zhoukuncheng.github.io/zh/posts/distributed-systems-for-fun-and-profit-part2/><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GH88YSLNJN"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GH88YSLNJN")}</script><meta property="og:url" content="https://zhoukuncheng.github.io/zh/posts/distributed-systems-for-fun-and-profit-part2/"><meta property="og:site_name" content="zhoukuncheng's Personal Blog"><meta property="og:title" content="Distributed Systems for Fun and Profit 笔记（二）"><meta property="og:description" content="2. 抽象的上下不同层次 系统模型 分布式系统中的程序：
在独立节点上同时运行
通过可能引入不确定性和消息丢失的网络连接
并且没有共享内存或共享时钟
系统模型列举了与特定系统设计相关的许多假设，实现分布式系统的环境和设施的假设：
节点具有什么功能以及它们如何失败 通信连接如何运行以及它们如何可能失败 整个系统的属性，例如关于时间和顺序的假设 健壮的系统模型做出最弱假设，强有力的假设创建易于推理的系统模型
此模型中的节点 作为计算和存储的主机：
执行程序的能力 能够将数据存储到内存和稳定持久状态的能力 时钟 节点执行确定性算法
故障模型：崩溃恢复而非拜占庭容错（任意错误）
此模型中的通信连接 通信连接将各个节点相互连接，并任一方向发送消息
网络不可靠，消息易延迟丢失
网络分区：网络断开但节点存活
时间和顺序的假设 信息最多以光速传播
如果距离不同，节点间消息的到达时间、顺序可能不同
同步系统模型 进程以锁定步骤执行；消息传输延迟有已知上限；每个进程都有准确的时钟
异步系统模型 没有时间假设，进程以独立的速率执行；消息传输延迟没有限制；有用的时钟不存在
共识问题 多个节点都同意一些值时达成共识
一致：每个正确节点都同意相同的值
完整：每个正确的进程最多只能决定一个值，如果决定某个值，那么一定是某些进程提议的
终止：所有进程最终达成决定
有效：如果所有正确进程提议相同的值 V，那么所有正确进程决定值 V
两种不可能的结果 FLP 不可能 假定节点只能因崩溃而失效；网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制，
在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法
CAP 定理 三个属性：
（强）一致性：所有节点同时看到相同的数据
可用性：节点故障不会阻止幸存者继续运行
分区容错：网络或节点故障导致消息丢失时，系统仍可继续运行
同时具备这三种属性的系统无法实现：
三种不同的系统类型：
CA（一致性+可用性）：完全严格的仲裁协议，例如两阶段提交 CP（一致性+分区容错）：多数仲裁协议，其中少数分区不可用，例如Paxos AP（可用性+分区容错）：使用冲突解决方案的协议，例如Dynamo 一致性模型：程序员与系统之间的合同，其中系统保证，如果程序员遵循某些特定规则，则对数据存储区的操作结果将是可预测的
强一致性模型（能够维护单个副本） Linearizable consistency （可线性化一致性） Sequential consistency （顺序一致性） 弱一致性 Client-centric consistency models （客户端为中心一致性） Causal consistency: strongest model available （因果一致性） Eventual consistency models （最终一致性） 线性化一致性要求操作生效的顺序等于操作的实际实时顺序，顺序一致性允许对操作进行重新排序，只要在每个节点上观察到的顺序保持一致"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-15T09:22:15+08:00"><meta property="article:modified_time" content="2020-09-15T09:22:15+08:00"><meta property="article:tag" content="分布式系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="Distributed Systems for Fun and Profit 笔记（二）"><meta name=twitter:description content="2. 抽象的上下不同层次
系统模型
分布式系统中的程序：


在独立节点上同时运行


通过可能引入不确定性和消息丢失的网络连接


并且没有共享内存或共享时钟


系统模型列举了与特定系统设计相关的许多假设，实现分布式系统的环境和设施的假设：

节点具有什么功能以及它们如何失败
通信连接如何运行以及它们如何可能失败
整个系统的属性，例如关于时间和顺序的假设

健壮的系统模型做出最弱假设，强有力的假设创建易于推理的系统模型
此模型中的节点
作为计算和存储的主机：

执行程序的能力
能够将数据存储到内存和稳定持久状态的能力
时钟

节点执行确定性算法
故障模型：崩溃恢复而非拜占庭容错（任意错误）
此模型中的通信连接
通信连接将各个节点相互连接，并任一方向发送消息
网络不可靠，消息易延迟丢失
网络分区：网络断开但节点存活
时间和顺序的假设
信息最多以光速传播
如果距离不同，节点间消息的到达时间、顺序可能不同
同步系统模型
进程以锁定步骤执行；消息传输延迟有已知上限；每个进程都有准确的时钟
异步系统模型
没有时间假设，进程以独立的速率执行；消息传输延迟没有限制；有用的时钟不存在
共识问题
多个节点都同意一些值时达成共识


一致：每个正确节点都同意相同的值


完整：每个正确的进程最多只能决定一个值，如果决定某个值，那么一定是某些进程提议的


终止：所有进程最终达成决定


有效：如果所有正确进程提议相同的值 V，那么所有正确进程决定值 V


两种不可能的结果
FLP 不可能
假定节点只能因崩溃而失效；网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制，
在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法
CAP 定理
三个属性：


（强）一致性：所有节点同时看到相同的数据


可用性：节点故障不会阻止幸存者继续运行


分区容错：网络或节点故障导致消息丢失时，系统仍可继续运行



同时具备这三种属性的系统无法实现：
三种不同的系统类型：

CA（一致性+可用性）：完全严格的仲裁协议，例如两阶段提交
CP（一致性+分区容错）：多数仲裁协议，其中少数分区不可用，例如Paxos
AP（可用性+分区容错）：使用冲突解决方案的协议，例如Dynamo


一致性模型：程序员与系统之间的合同，其中系统保证，如果程序员遵循某些特定规则，则对数据存储区的操作结果将是可预测的

强一致性模型（能够维护单个副本）

Linearizable consistency （可线性化一致性）
Sequential consistency （顺序一致性）


弱一致性

Client-centric consistency models （客户端为中心一致性）
Causal consistency: strongest model available （因果一致性）
Eventual consistency models （最终一致性）



线性化一致性要求操作生效的顺序等于操作的实际实时顺序，顺序一致性允许对操作进行重新排序，只要在每个节点上观察到的顺序保持一致"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"Distributed Systems for Fun and Profit 笔记（二）","item":"https://zhoukuncheng.github.io/zh/posts/distributed-systems-for-fun-and-profit-part2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Distributed Systems for Fun and Profit 笔记（二）","name":"Distributed Systems for Fun and Profit 笔记（二）","description":"2. 抽象的上下不同层次 系统模型 分布式系统中的程序：\n在独立节点上同时运行\n通过可能引入不确定性和消息丢失的网络连接\n并且没有共享内存或共享时钟\n系统模型列举了与特定系统设计相关的许多假设，实现分布式系统的环境和设施的假设：\n节点具有什么功能以及它们如何失败 通信连接如何运行以及它们如何可能失败 整个系统的属性，例如关于时间和顺序的假设 健壮的系统模型做出最弱假设，强有力的假设创建易于推理的系统模型\n此模型中的节点 作为计算和存储的主机：\n执行程序的能力 能够将数据存储到内存和稳定持久状态的能力 时钟 节点执行确定性算法\n故障模型：崩溃恢复而非拜占庭容错（任意错误）\n此模型中的通信连接 通信连接将各个节点相互连接，并任一方向发送消息\n网络不可靠，消息易延迟丢失\n网络分区：网络断开但节点存活\n时间和顺序的假设 信息最多以光速传播\n如果距离不同，节点间消息的到达时间、顺序可能不同\n同步系统模型 进程以锁定步骤执行；消息传输延迟有已知上限；每个进程都有准确的时钟\n异步系统模型 没有时间假设，进程以独立的速率执行；消息传输延迟没有限制；有用的时钟不存在\n共识问题 多个节点都同意一些值时达成共识\n一致：每个正确节点都同意相同的值\n完整：每个正确的进程最多只能决定一个值，如果决定某个值，那么一定是某些进程提议的\n终止：所有进程最终达成决定\n有效：如果所有正确进程提议相同的值 V，那么所有正确进程决定值 V\n两种不可能的结果 FLP 不可能 假定节点只能因崩溃而失效；网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制，\n在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法\nCAP 定理 三个属性：\n（强）一致性：所有节点同时看到相同的数据\n可用性：节点故障不会阻止幸存者继续运行\n分区容错：网络或节点故障导致消息丢失时，系统仍可继续运行\n同时具备这三种属性的系统无法实现：\n三种不同的系统类型：\nCA（一致性+可用性）：完全严格的仲裁协议，例如两阶段提交 CP（一致性+分区容错）：多数仲裁协议，其中少数分区不可用，例如Paxos AP（可用性+分区容错）：使用冲突解决方案的协议，例如Dynamo 一致性模型：程序员与系统之间的合同，其中系统保证，如果程序员遵循某些特定规则，则对数据存储区的操作结果将是可预测的\n强一致性模型（能够维护单个副本） Linearizable consistency （可线性化一致性） Sequential consistency （顺序一致性） 弱一致性 Client-centric consistency models （客户端为中心一致性） Causal consistency: strongest model available （因果一致性） Eventual consistency models （最终一致性） 线性化一致性要求操作生效的顺序等于操作的实际实时顺序，顺序一致性允许对操作进行重新排序，只要在每个节点上观察到的顺序保持一致\n","keywords":["分布式系统"],"articleBody":"2. 抽象的上下不同层次 系统模型 分布式系统中的程序：\n在独立节点上同时运行\n通过可能引入不确定性和消息丢失的网络连接\n并且没有共享内存或共享时钟\n系统模型列举了与特定系统设计相关的许多假设，实现分布式系统的环境和设施的假设：\n节点具有什么功能以及它们如何失败 通信连接如何运行以及它们如何可能失败 整个系统的属性，例如关于时间和顺序的假设 健壮的系统模型做出最弱假设，强有力的假设创建易于推理的系统模型\n此模型中的节点 作为计算和存储的主机：\n执行程序的能力 能够将数据存储到内存和稳定持久状态的能力 时钟 节点执行确定性算法\n故障模型：崩溃恢复而非拜占庭容错（任意错误）\n此模型中的通信连接 通信连接将各个节点相互连接，并任一方向发送消息\n网络不可靠，消息易延迟丢失\n网络分区：网络断开但节点存活\n时间和顺序的假设 信息最多以光速传播\n如果距离不同，节点间消息的到达时间、顺序可能不同\n同步系统模型 进程以锁定步骤执行；消息传输延迟有已知上限；每个进程都有准确的时钟\n异步系统模型 没有时间假设，进程以独立的速率执行；消息传输延迟没有限制；有用的时钟不存在\n共识问题 多个节点都同意一些值时达成共识\n一致：每个正确节点都同意相同的值\n完整：每个正确的进程最多只能决定一个值，如果决定某个值，那么一定是某些进程提议的\n终止：所有进程最终达成决定\n有效：如果所有正确进程提议相同的值 V，那么所有正确进程决定值 V\n两种不可能的结果 FLP 不可能 假定节点只能因崩溃而失效；网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制，\n在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法\nCAP 定理 三个属性：\n（强）一致性：所有节点同时看到相同的数据\n可用性：节点故障不会阻止幸存者继续运行\n分区容错：网络或节点故障导致消息丢失时，系统仍可继续运行\n同时具备这三种属性的系统无法实现：\n三种不同的系统类型：\nCA（一致性+可用性）：完全严格的仲裁协议，例如两阶段提交 CP（一致性+分区容错）：多数仲裁协议，其中少数分区不可用，例如Paxos AP（可用性+分区容错）：使用冲突解决方案的协议，例如Dynamo 一致性模型：程序员与系统之间的合同，其中系统保证，如果程序员遵循某些特定规则，则对数据存储区的操作结果将是可预测的\n强一致性模型（能够维护单个副本） Linearizable consistency （可线性化一致性） Sequential consistency （顺序一致性） 弱一致性 Client-centric consistency models （客户端为中心一致性） Causal consistency: strongest model available （因果一致性） Eventual consistency models （最终一致性） 线性化一致性要求操作生效的顺序等于操作的实际实时顺序，顺序一致性允许对操作进行重新排序，只要在每个节点上观察到的顺序保持一致\n","wordCount":"78","inLanguage":"zh","datePublished":"2020-09-15T09:22:15+08:00","dateModified":"2020-09-15T09:22:15+08:00","author":{"@type":"Person","name":"zhoukuncheng"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/zh/posts/distributed-systems-for-fun-and-profit-part2/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/zh/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://zhoukuncheng.github.io/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/zh/ title=首页><span>首页</span></a></li><li><a href=https://zhoukuncheng.github.io/zh/posts/ title=归档><span>归档</span></a></li><li><a href=https://zhoukuncheng.github.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://zhoukuncheng.github.io/zh/categories/ title=分类><span>分类</span></a></li><li><a href=https://zhoukuncheng.github.io/zh/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Distributed Systems for Fun and Profit 笔记（二）</h1><div class=post-meta><span title='2020-09-15 09:22:15 +0800 +0800'>2020年9月15日</span>&nbsp;·&nbsp;<span>zhoukuncheng</span>&nbsp;|&nbsp;<span>语言:</span><ul class=i18n_list><li><a href=https://zhoukuncheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/>En</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#2-%e6%8a%bd%e8%b1%a1%e7%9a%84%e4%b8%8a%e4%b8%8b%e4%b8%8d%e5%90%8c%e5%b1%82%e6%ac%a1 aria-label="2. 抽象的上下不同层次">2. 抽象的上下不同层次</a><ul><li><a href=#%e7%b3%bb%e7%bb%9f%e6%a8%a1%e5%9e%8b aria-label=系统模型>系统模型</a><ul><li><a href=#%e6%ad%a4%e6%a8%a1%e5%9e%8b%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9 aria-label=此模型中的节点>此模型中的节点</a></li><li><a href=#%e6%ad%a4%e6%a8%a1%e5%9e%8b%e4%b8%ad%e7%9a%84%e9%80%9a%e4%bf%a1%e8%bf%9e%e6%8e%a5 aria-label=此模型中的通信连接>此模型中的通信连接</a></li><li><a href=#%e6%97%b6%e9%97%b4%e5%92%8c%e9%a1%ba%e5%ba%8f%e7%9a%84%e5%81%87%e8%ae%be aria-label=时间和顺序的假设>时间和顺序的假设</a><ul><li><a href=#%e5%90%8c%e6%ad%a5%e7%b3%bb%e7%bb%9f%e6%a8%a1%e5%9e%8b aria-label=同步系统模型>同步系统模型</a></li><li><a href=#%e5%bc%82%e6%ad%a5%e7%b3%bb%e7%bb%9f%e6%a8%a1%e5%9e%8b aria-label=异步系统模型>异步系统模型</a></li></ul></li><li><a href=#%e5%85%b1%e8%af%86%e9%97%ae%e9%a2%98 aria-label=共识问题>共识问题</a></li></ul></li><li><a href=#%e4%b8%a4%e7%a7%8d%e4%b8%8d%e5%8f%af%e8%83%bd%e7%9a%84%e7%bb%93%e6%9e%9c aria-label=两种不可能的结果>两种不可能的结果</a><ul><li><a href=#flp-%e4%b8%8d%e5%8f%af%e8%83%bd aria-label="FLP 不可能">FLP 不可能</a></li><li><a href=#cap-%e5%ae%9a%e7%90%86 aria-label="CAP 定理">CAP 定理</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=2-抽象的上下不同层次>2. 抽象的上下不同层次<a hidden class=anchor aria-hidden=true href=#2-抽象的上下不同层次>#</a></h2><h3 id=系统模型>系统模型<a hidden class=anchor aria-hidden=true href=#系统模型>#</a></h3><p>分布式系统中的程序：</p><ul><li><p>在独立节点上同时运行</p></li><li><p>通过可能引入不确定性和消息丢失的网络连接</p></li><li><p>并且没有共享内存或共享时钟</p></li></ul><p>系统模型列举了与特定系统设计相关的许多假设，实现分布式系统的环境和设施的假设：</p><ul><li>节点具有什么功能以及它们如何失败</li><li>通信连接如何运行以及它们如何可能失败</li><li>整个系统的属性，例如关于时间和顺序的假设</li></ul><p>健壮的系统模型做出最弱假设，强有力的假设创建易于推理的系统模型</p><h4 id=此模型中的节点>此模型中的节点<a hidden class=anchor aria-hidden=true href=#此模型中的节点>#</a></h4><p>作为计算和存储的主机：</p><ul><li>执行程序的能力</li><li>能够将数据存储到内存和稳定持久状态的能力</li><li>时钟</li></ul><p>节点执行确定性算法</p><p>故障模型：崩溃恢复而非拜占庭容错（任意错误）</p><h4 id=此模型中的通信连接>此模型中的通信连接<a hidden class=anchor aria-hidden=true href=#此模型中的通信连接>#</a></h4><p>通信连接将各个节点相互连接，并任一方向发送消息</p><p>网络不可靠，消息易延迟丢失</p><p>网络分区：网络断开但节点存活</p><h4 id=时间和顺序的假设>时间和顺序的假设<a hidden class=anchor aria-hidden=true href=#时间和顺序的假设>#</a></h4><p>信息最多以光速传播</p><p>如果距离不同，节点间消息的到达时间、顺序可能不同</p><h5 id=同步系统模型>同步系统模型<a hidden class=anchor aria-hidden=true href=#同步系统模型>#</a></h5><p>进程以锁定步骤执行；消息传输延迟有已知上限；每个进程都有准确的时钟</p><h5 id=异步系统模型>异步系统模型<a hidden class=anchor aria-hidden=true href=#异步系统模型>#</a></h5><p>没有时间假设，进程以独立的速率执行；消息传输延迟没有限制；有用的时钟不存在</p><h4 id=共识问题>共识问题<a hidden class=anchor aria-hidden=true href=#共识问题>#</a></h4><p>多个节点都同意一些值时达成共识</p><ol><li><p>一致：每个正确节点都同意相同的值</p></li><li><p>完整：每个正确的进程最多只能决定一个值，如果决定某个值，那么一定是某些进程提议的</p></li><li><p>终止：所有进程最终达成决定</p></li><li><p>有效：如果所有正确进程提议相同的值 V，那么所有正确进程决定值 V</p></li></ol><h3 id=两种不可能的结果>两种不可能的结果<a hidden class=anchor aria-hidden=true href=#两种不可能的结果>#</a></h3><h4 id=flp-不可能>FLP 不可能<a hidden class=anchor aria-hidden=true href=#flp-不可能>#</a></h4><p>假定节点只能因崩溃而失效；网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制，</p><p>在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法</p><h4 id=cap-定理>CAP 定理<a hidden class=anchor aria-hidden=true href=#cap-定理>#</a></h4><p>三个属性：</p><ul><li><p>（强）一致性：所有节点同时看到相同的数据</p></li><li><p>可用性：节点故障不会阻止幸存者继续运行</p></li><li><p>分区容错：网络或节点故障导致消息丢失时，系统仍可继续运行</p></li></ul><p><img loading=lazy src=/static/CAP.png></p><p>同时具备这三种属性的系统无法实现：</p><p>三种不同的系统类型：</p><ul><li>CA（一致性+可用性）：完全严格的仲裁协议，例如两阶段提交</li><li>CP（一致性+分区容错）：多数仲裁协议，其中少数分区不可用，例如Paxos</li><li>AP（可用性+分区容错）：使用冲突解决方案的协议，例如Dynamo</li></ul><p><img loading=lazy src=/static/CAP_choice.png></p><p>一致性模型：程序员与系统之间的合同，其中系统保证，如果程序员遵循某些特定规则，则对数据存储区的操作结果将是可预测的</p><ul><li>强一致性模型（能够维护单个副本）<ul><li>Linearizable consistency （可线性化一致性）</li><li>Sequential consistency （顺序一致性）</li></ul></li><li>弱一致性<ul><li>Client-centric consistency models （客户端为中心一致性）</li><li>Causal consistency: strongest model available （因果一致性）</li><li>Eventual consistency models （最终一致性）</li></ul></li></ul><p>线性化一致性要求操作生效的顺序等于操作的实际实时顺序，顺序一致性允许对操作进行重新排序，只要在每个节点上观察到的顺序保持一致</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/zh/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/>分布式系统</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=purple_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://zhoukuncheng.github.io/zh/>zhoukuncheng's Personal Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>