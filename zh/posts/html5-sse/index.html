<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>流畅的实时数据流：像 ChatGPT 一样掌握 HTML5 SSE | zhoukuncheng's Personal Blog</title><meta name=keywords content="Golang,JavaScipt,HTTP"><meta name=description content="简介
在像 ChatGPT 这样的服务表现出色的实时交互时代，对于开发者来说，利用能够在应用程序中实现无缝数据流的技术至关重要。本文将深入探讨 HTML5 服务器发送事件 (Server-Sent Events, SSE) 的世界，这是一个类似于对话式 AI 接口背后的强大工具。就像 ChatGPT 通过流式传输数据来提供即时响应一样，SSE 使网络浏览器能够从服务器接收更新，而无需重复的客户端请求。无论你是构建聊天应用程序、实时通知系统，还是任何需要实时数据流的服务，本指南都将为你提供在应用程序中高效实施 SSE 的知识，确保响应迅速且引人入胜的用户体验。
理解服务器发送事件 (SSE)
服务器发送事件 (SSE) 是一种 Web 技术，它促进了服务器通过已建立的 HTTP 连接向客户端发送实时更新的能力。客户端可以通过 EventSource JavaScript API 接收连续的数据流或消息，该 API 包含在 WHATWG 的 HTML5 规范中。SSE 的官方媒体类型是 text/event-stream。
下面是一个典型 SSE 响应的说明性示例：
event:message
data:The Current Time Is 2023-12-30 23:00:21

event:message
data:The Current Time Is 2023-12-30 23:00:31

event:message
data:The Current Time Is 2023-12-30 23:00:41

event:message
data:The Current Time Is 2023-12-30 23:00:51
SSE 消息中的字段
通过 SSE 传输的消息可能包含以下字段："><meta name=author content="zhoukuncheng"><link rel=canonical href=https://zhoukuncheng.github.io/zh/posts/html5-sse/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://zhoukuncheng.github.io/zh/posts/html5-sse/><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/html5-sse/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GH88YSLNJN"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GH88YSLNJN")}</script><meta property="og:url" content="https://zhoukuncheng.github.io/zh/posts/html5-sse/"><meta property="og:site_name" content="zhoukuncheng's Personal Blog"><meta property="og:title" content="流畅的实时数据流：像 ChatGPT 一样掌握 HTML5 SSE"><meta property="og:description" content="简介 在像 ChatGPT 这样的服务表现出色的实时交互时代，对于开发者来说，利用能够在应用程序中实现无缝数据流的技术至关重要。本文将深入探讨 HTML5 服务器发送事件 (Server-Sent Events, SSE) 的世界，这是一个类似于对话式 AI 接口背后的强大工具。就像 ChatGPT 通过流式传输数据来提供即时响应一样，SSE 使网络浏览器能够从服务器接收更新，而无需重复的客户端请求。无论你是构建聊天应用程序、实时通知系统，还是任何需要实时数据流的服务，本指南都将为你提供在应用程序中高效实施 SSE 的知识，确保响应迅速且引人入胜的用户体验。
理解服务器发送事件 (SSE) 服务器发送事件 (SSE) 是一种 Web 技术，它促进了服务器通过已建立的 HTTP 连接向客户端发送实时更新的能力。客户端可以通过 EventSource JavaScript API 接收连续的数据流或消息，该 API 包含在 WHATWG 的 HTML5 规范中。SSE 的官方媒体类型是 text/event-stream。
下面是一个典型 SSE 响应的说明性示例：
event:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 SSE 消息中的字段 通过 SSE 传输的消息可能包含以下字段："><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-30T23:11:34+08:00"><meta property="article:modified_time" content="2023-12-30T23:11:34+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="JavaScipt"><meta property="article:tag" content="HTTP"><meta name=twitter:card content="summary"><meta name=twitter:title content="流畅的实时数据流：像 ChatGPT 一样掌握 HTML5 SSE"><meta name=twitter:description content="简介
在像 ChatGPT 这样的服务表现出色的实时交互时代，对于开发者来说，利用能够在应用程序中实现无缝数据流的技术至关重要。本文将深入探讨 HTML5 服务器发送事件 (Server-Sent Events, SSE) 的世界，这是一个类似于对话式 AI 接口背后的强大工具。就像 ChatGPT 通过流式传输数据来提供即时响应一样，SSE 使网络浏览器能够从服务器接收更新，而无需重复的客户端请求。无论你是构建聊天应用程序、实时通知系统，还是任何需要实时数据流的服务，本指南都将为你提供在应用程序中高效实施 SSE 的知识，确保响应迅速且引人入胜的用户体验。
理解服务器发送事件 (SSE)
服务器发送事件 (SSE) 是一种 Web 技术，它促进了服务器通过已建立的 HTTP 连接向客户端发送实时更新的能力。客户端可以通过 EventSource JavaScript API 接收连续的数据流或消息，该 API 包含在 WHATWG 的 HTML5 规范中。SSE 的官方媒体类型是 text/event-stream。
下面是一个典型 SSE 响应的说明性示例：
event:message
data:The Current Time Is 2023-12-30 23:00:21

event:message
data:The Current Time Is 2023-12-30 23:00:31

event:message
data:The Current Time Is 2023-12-30 23:00:41

event:message
data:The Current Time Is 2023-12-30 23:00:51
SSE 消息中的字段
通过 SSE 传输的消息可能包含以下字段："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"流畅的实时数据流：像 ChatGPT 一样掌握 HTML5 SSE","item":"https://zhoukuncheng.github.io/zh/posts/html5-sse/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"流畅的实时数据流：像 ChatGPT 一样掌握 HTML5 SSE","name":"流畅的实时数据流：像 ChatGPT 一样掌握 HTML5 SSE","description":"简介 在像 ChatGPT 这样的服务表现出色的实时交互时代，对于开发者来说，利用能够在应用程序中实现无缝数据流的技术至关重要。本文将深入探讨 HTML5 服务器发送事件 (Server-Sent Events, SSE) 的世界，这是一个类似于对话式 AI 接口背后的强大工具。就像 ChatGPT 通过流式传输数据来提供即时响应一样，SSE 使网络浏览器能够从服务器接收更新，而无需重复的客户端请求。无论你是构建聊天应用程序、实时通知系统，还是任何需要实时数据流的服务，本指南都将为你提供在应用程序中高效实施 SSE 的知识，确保响应迅速且引人入胜的用户体验。\n理解服务器发送事件 (SSE) 服务器发送事件 (SSE) 是一种 Web 技术，它促进了服务器通过已建立的 HTTP 连接向客户端发送实时更新的能力。客户端可以通过 EventSource JavaScript API 接收连续的数据流或消息，该 API 包含在 WHATWG 的 HTML5 规范中。SSE 的官方媒体类型是 text/event-stream。\n下面是一个典型 SSE 响应的说明性示例：\nevent:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 SSE 消息中的字段 通过 SSE 传输的消息可能包含以下字段：\n","keywords":["Golang","JavaScipt","HTTP"],"articleBody":"简介 在像 ChatGPT 这样的服务表现出色的实时交互时代，对于开发者来说，利用能够在应用程序中实现无缝数据流的技术至关重要。本文将深入探讨 HTML5 服务器发送事件 (Server-Sent Events, SSE) 的世界，这是一个类似于对话式 AI 接口背后的强大工具。就像 ChatGPT 通过流式传输数据来提供即时响应一样，SSE 使网络浏览器能够从服务器接收更新，而无需重复的客户端请求。无论你是构建聊天应用程序、实时通知系统，还是任何需要实时数据流的服务，本指南都将为你提供在应用程序中高效实施 SSE 的知识，确保响应迅速且引人入胜的用户体验。\n理解服务器发送事件 (SSE) 服务器发送事件 (SSE) 是一种 Web 技术，它促进了服务器通过已建立的 HTTP 连接向客户端发送实时更新的能力。客户端可以通过 EventSource JavaScript API 接收连续的数据流或消息，该 API 包含在 WHATWG 的 HTML5 规范中。SSE 的官方媒体类型是 text/event-stream。\n下面是一个典型 SSE 响应的说明性示例：\nevent:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 SSE 消息中的字段 通过 SSE 传输的消息可能包含以下字段：\nevent: 指定事件类型的字符串。如果指定了，浏览器会将事件分派给相应的事件名称监听器。使用 addEventListener() 来监听命名事件。如果未指定事件名称，则调用 onmessage 处理程序。\ndata: 此字段包含消息内容。如果 EventSource 接收到以 data: 开头的多个连续行，它会将它们连接起来，在每一行之间插入一个换行符。任何末尾的换行符都会被去除。\nid: 一个标识符，用于设置 EventSource 对象的最后事件 ID 值。\nretry: 以毫秒为单位的重新连接时间。如果服务器连接断开，浏览器将在尝试重新连接之前等待此持续时间。非整数值将被忽略。\n示例实现 让我们看一个使用 Go Gin SSE 的简单示例来演示 SSE 功能。\n客户端代码 在客户端，只需要少量的 HTML 和 JavaScript。\n\u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eServer Sent Event Example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"event-data\"\u003e\u003c/div\u003e \u003cscript\u003e // JavaScript 中的 EventSource 对象监听来自我们 Go 服务器的流式事件并显示消息。 const stream = new EventSource(\"/stream\"); stream.onmessage = function (e) { // 将消息数据追加到 event-data div 中 const eventDataElement = document.getElementById('event-data'); eventDataElement.innerHTML += e.data + \"\n\"; }; \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 解释 EventSource 对象自动建立与服务器端点 /stream 的连接，该端点应设置为发送连续事件。 为 stream 对象添加了一个 “message” 事件的事件监听器，以处理传入的消息。 来自事件的数据 (e.data) 被追加到 event-data div 的内容中，每条消息占一行。 服务端代码 服务端的核心逻辑（使用 Go channel）允许管理多个客户端。\n// 中间件，用于设置 SSE 必要的头部 func HeadersMiddleware() gin.HandlerFunc { return func(c *gin.Context) { c.Writer.Header().Set(\"Content-Type\", \"text/event-stream\") c.Writer.Header().Set(\"Cache-Control\", \"no-cache\") c.Writer.Header().Set(\"Connection\", \"keep-alive\") c.Writer.Header().Set(\"Transfer-Encoding\", \"chunked\") c.Next() } } // 向客户端流式传输消息的端点 authorized.GET(\"/stream\", HeadersMiddleware(), func(c *gin.Context) { clientChan, ok := c.Get(\"clientChan\") if !ok { return } c.Stream(func(w io.Writer) bool { if msg, ok := \u003c-clientChan; ok { c.SSEvent(\"message\", msg) return true } return false }) }) 让我们探索一下 Gin 框架中的 SSEvent 方法：\n// SSEvent 将服务器发送事件写入 body 流。 func (c *Context) SSEvent(name string, message any) { c.Render(-1, sse.Event{ Event: name, Data: message, }) } // SSE 的 Event 结构体 type Event struct { Event string Id string Retry uint Data interface{} } 应对挑战 虽然 SSE 的客户端和服务端代码看起来很简单，但构建生产级 SSE 应用程序会引入复杂性。JavaScript SSE API 有一定的局限性：\n仅支持 GET 方法。 无法发送请求体。 不允许自定义头部，这对于传递身份验证令牌可能至关重要。 对重试策略的控制有限，浏览器在停止之前会尝试重新连接几次。 增强灵活性的解决方案 为了克服 JavaScript EventSource API 的限制，可以考虑使用第三方库，例如 Azure 的 fetch-event-source。该库利用 Fetch API 来管理服务器发送事件，提供了对请求方法、头部和消息体更大的控制权。\nfetch-event-source 库的使用示例：\n// 使用 fetch-event-source 库以获得更大的灵活性 import { fetchEventSource } from '@microsoft/fetch-event-source'; const ctrl = new AbortController(); fetchEventSource('/api/sse', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer your-access-token' }, body: JSON.stringify({ foo: 'bar' }), signal: ctrl.signal, onmessage(ev) { console.log(ev.data); }, onopen(response) { // 处理打开事件 }, onerror(err) { // 处理错误 }, onclose() { // 处理关闭事件 } }); 结论 虽然使用 SSE 和 EventSource API 进行 HTTP 流式传输直观且简单，但有限的自定义选项可能会阻碍全面的生产应用程序的开发。使用第三方 EventSource 实现可以提供稳健应用程序所需的必要灵活性和控制。\n参考资料 Server-Sent Events mdn docs Server-Sent Events Standard Using SSE with Gin ","wordCount":"387","inLanguage":"zh","datePublished":"2023-12-30T23:11:34+08:00","dateModified":"2023-12-30T23:11:34+08:00","author":{"@type":"Person","name":"zhoukuncheng"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/zh/posts/html5-sse/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/zh/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://zhoukuncheng.github.io/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/zh/ title=首页><span>首页</span></a></li><li><a href=https://zhoukuncheng.github.io/zh/posts/ title=归档><span>归档</span></a></li><li><a href=https://zhoukuncheng.github.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://zhoukuncheng.github.io/zh/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">流畅的实时数据流：像 ChatGPT 一样掌握 HTML5 SSE</h1><div class=post-meta><span title='2023-12-30 23:11:34 +0800 +0800'>2023年12月30日</span>&nbsp;·&nbsp;<span>zhoukuncheng</span>&nbsp;|&nbsp;<span>语言:</span><ul class=i18n_list><li><a href=https://zhoukuncheng.github.io/posts/html5-sse/>En</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a><ul><li><a href=#%e7%90%86%e8%a7%a3%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e9%80%81%e4%ba%8b%e4%bb%b6-sse aria-label="理解服务器发送事件 (SSE)">理解服务器发送事件 (SSE)</a><ul><li><a href=#sse-%e6%b6%88%e6%81%af%e4%b8%ad%e7%9a%84%e5%ad%97%e6%ae%b5 aria-label="SSE 消息中的字段">SSE 消息中的字段</a></li></ul></li><li><a href=#%e7%a4%ba%e4%be%8b%e5%ae%9e%e7%8e%b0 aria-label=示例实现>示例实现</a><ul><li><a href=#%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bb%a3%e7%a0%81 aria-label=客户端代码>客户端代码</a><ul><li><a href=#%e8%a7%a3%e9%87%8a aria-label=解释>解释</a></li></ul></li><li><a href=#%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bb%a3%e7%a0%81 aria-label=服务端代码>服务端代码</a></li></ul></li></ul></li><li><a href=#%e5%ba%94%e5%af%b9%e6%8c%91%e6%88%98 aria-label=应对挑战>应对挑战</a></li><li><a href=#%e5%a2%9e%e5%bc%ba%e7%81%b5%e6%b4%bb%e6%80%a7%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=增强灵活性的解决方案>增强灵活性的解决方案</a></li><li><a href=#%e7%bb%93%e8%ae%ba aria-label=结论>结论</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><h1 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h1><p>在像 ChatGPT 这样的服务表现出色的实时交互时代，对于开发者来说，利用能够在应用程序中实现无缝数据流的技术至关重要。本文将深入探讨 HTML5 服务器发送事件 (Server-Sent Events, SSE) 的世界，这是一个类似于对话式 AI 接口背后的强大工具。就像 ChatGPT 通过流式传输数据来提供即时响应一样，SSE 使网络浏览器能够从服务器接收更新，而无需重复的客户端请求。无论你是构建聊天应用程序、实时通知系统，还是任何需要实时数据流的服务，本指南都将为你提供在应用程序中高效实施 SSE 的知识，确保响应迅速且引人入胜的用户体验。</p><h2 id=理解服务器发送事件-sse>理解服务器发送事件 (SSE)<a hidden class=anchor aria-hidden=true href=#理解服务器发送事件-sse>#</a></h2><p>服务器发送事件 (SSE) 是一种 Web 技术，它促进了服务器通过已建立的 HTTP 连接向客户端发送实时更新的能力。客户端可以通过 EventSource JavaScript API 接收连续的数据流或消息，该 API 包含在 WHATWG 的 HTML5 规范中。SSE 的官方媒体类型是 <code>text/event-stream</code>。</p><p>下面是一个典型 SSE 响应的说明性示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:21
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:31
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:41
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:51
</span></span></code></pre></div><h3 id=sse-消息中的字段>SSE 消息中的字段<a hidden class=anchor aria-hidden=true href=#sse-消息中的字段>#</a></h3><p>通过 SSE 传输的消息可能包含以下字段：</p><ul><li><p><code>event</code>: 指定事件类型的字符串。如果指定了，浏览器会将事件分派给相应的事件名称监听器。使用 <code>addEventListener()</code> 来监听命名事件。如果未指定事件名称，则调用 <code>onmessage</code> 处理程序。</p></li><li><p><code>data</code>: 此字段包含消息内容。如果 <code>EventSource</code> 接收到以 <code>data:</code> 开头的多个连续行，它会将它们连接起来，在每一行之间插入一个换行符。任何末尾的换行符都会被去除。</p></li><li><p><code>id</code>: 一个标识符，用于设置 <code>EventSource</code> 对象的最后事件 ID 值。</p></li><li><p><code>retry</code>: 以毫秒为单位的重新连接时间。如果服务器连接断开，浏览器将在尝试重新连接之前等待此持续时间。非整数值将被忽略。</p></li></ul><h2 id=示例实现>示例实现<a hidden class=anchor aria-hidden=true href=#示例实现>#</a></h2><p>让我们看一个使用 <a href=https://github.com/gin-gonic/examples/tree/master/server-sent-event>Go Gin SSE</a> 的简单示例来演示 SSE 功能。</p><h3 id=客户端代码>客户端代码<a hidden class=anchor aria-hidden=true href=#客户端代码>#</a></h3><p>在客户端，只需要少量的 HTML 和 JavaScript。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=cp>&lt;!doctype html&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span> <span class=na>lang</span><span class=o>=</span><span class=s>&#34;en&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>charset</span><span class=o>=</span><span class=s>&#34;UTF-8&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>Server Sent Event Example<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>div</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;event-data&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// JavaScript 中的 EventSource 对象监听来自我们 Go 服务器的流式事件并显示消息。
</span></span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>stream</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>EventSource</span><span class=p>(</span><span class=s2>&#34;/stream&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>stream</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 将消息数据追加到 event-data div 中
</span></span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>eventDataElement</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;event-data&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>eventDataElement</span><span class=p>.</span><span class=nx>innerHTML</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span> <span class=o>+</span> <span class=s2>&#34;&lt;br&gt;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=解释>解释<a hidden class=anchor aria-hidden=true href=#解释>#</a></h4><ul><li><code>EventSource</code> 对象自动建立与服务器端点 <code>/stream</code> 的连接，该端点应设置为发送连续事件。</li><li>为 <code>stream</code> 对象添加了一个 &ldquo;message&rdquo; 事件的事件监听器，以处理传入的消息。</li><li>来自事件的数据 (<code>e.data</code>) 被追加到 <code>event-data</code> div 的内容中，每条消息占一行。</li></ul><h3 id=服务端代码>服务端代码<a hidden class=anchor aria-hidden=true href=#服务端代码>#</a></h3><p>服务端的核心逻辑（使用 Go channel）允许管理多个客户端。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 中间件，用于设置 SSE 必要的头部</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>HeadersMiddleware</span><span class=p>()</span><span class=w> </span><span class=nx>gin</span><span class=p>.</span><span class=nx>HandlerFunc</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Content-Type&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;text/event-stream&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Cache-Control&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;no-cache&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Connection&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;keep-alive&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Transfer-Encoding&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;chunked&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 向客户端流式传输消息的端点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>authorized</span><span class=p>.</span><span class=nf>GET</span><span class=p>(</span><span class=s>&#34;/stream&#34;</span><span class=p>,</span><span class=w> </span><span class=nf>HeadersMiddleware</span><span class=p>(),</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>clientChan</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;clientChan&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nf>Stream</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span><span class=w> </span><span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>msg</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&lt;-</span><span class=nx>clientChan</span><span class=p>;</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>c</span><span class=p>.</span><span class=nf>SSEvent</span><span class=p>(</span><span class=s>&#34;message&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>msg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>})</span><span class=w>
</span></span></span></code></pre></div><p>让我们探索一下 Gin 框架中的 <code>SSEvent</code> 方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// SSEvent 将服务器发送事件写入 body 流。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>Context</span><span class=p>)</span><span class=w> </span><span class=nf>SSEvent</span><span class=p>(</span><span class=nx>name</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>message</span><span class=w> </span><span class=kt>any</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nf>Render</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=nx>sse</span><span class=p>.</span><span class=nx>Event</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>Event</span><span class=p>:</span><span class=w> </span><span class=nx>name</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>Data</span><span class=p>:</span><span class=w>  </span><span class=nx>message</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// SSE 的 Event 结构体</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Event</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>Event</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>Id</span><span class=w>    </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>Retry</span><span class=w> </span><span class=kt>uint</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>Data</span><span class=w>  </span><span class=kd>interface</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h1 id=应对挑战>应对挑战<a hidden class=anchor aria-hidden=true href=#应对挑战>#</a></h1><p>虽然 SSE 的客户端和服务端代码看起来很简单，但构建生产级 SSE 应用程序会引入复杂性。JavaScript SSE API 有一定的局限性：</p><ul><li>仅支持 GET 方法。</li><li>无法发送请求体。</li><li>不允许自定义头部，这对于传递身份验证令牌可能至关重要。</li><li>对重试策略的控制有限，浏览器在停止之前会尝试重新连接几次。</li></ul><h1 id=增强灵活性的解决方案>增强灵活性的解决方案<a hidden class=anchor aria-hidden=true href=#增强灵活性的解决方案>#</a></h1><p>为了克服 JavaScript EventSource API 的限制，可以考虑使用第三方库，例如 Azure 的 <a href=https://github.com/Azure/fetch-event-source>fetch-event-source</a>。该库利用 Fetch API 来管理服务器发送事件，提供了对请求方法、头部和消息体更大的控制权。</p><p><code>fetch-event-source</code> 库的使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 使用 fetch-event-source 库以获得更大的灵活性
</span></span></span><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>fetchEventSource</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;@microsoft/fetch-event-source&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ctrl</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>AbortController</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fetchEventSource</span><span class=p>(</span><span class=s1>&#39;/api/sse&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>method</span><span class=o>:</span> <span class=s1>&#39;POST&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>headers</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Content-Type&#39;</span><span class=o>:</span> <span class=s1>&#39;application/json&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Authorization&#39;</span><span class=o>:</span> <span class=s1>&#39;Bearer your-access-token&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>body</span><span class=o>:</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span> <span class=nx>foo</span><span class=o>:</span> <span class=s1>&#39;bar&#39;</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>    <span class=nx>signal</span><span class=o>:</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nx>signal</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>onmessage</span><span class=p>(</span><span class=nx>ev</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>ev</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>onopen</span><span class=p>(</span><span class=nx>response</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 处理打开事件
</span></span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>onerror</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 处理错误
</span></span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>onclose</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 处理关闭事件
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><h1 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h1><p>虽然使用 SSE 和 EventSource API 进行 HTTP 流式传输直观且简单，但有限的自定义选项可能会阻碍全面的生产应用程序的开发。使用第三方 EventSource 实现可以提供稳健应用程序所需的必要灵活性和控制。</p><h1 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h1><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events>Server-Sent Events mdn docs</a></li><li><a href=https://html.spec.whatwg.org/multipage/server-sent-events.html>Server-Sent Events Standard</a></li><li><a href=https://github.com/gin-gonic/examples/tree/master/server-sent-event>Using SSE with Gin</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/zh/tags/golang/>Golang</a></li><li><a href=https://zhoukuncheng.github.io/zh/tags/javascipt/>JavaScipt</a></li><li><a href=https://zhoukuncheng.github.io/zh/tags/http/>HTTP</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=purple_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://zhoukuncheng.github.io/zh/>zhoukuncheng's Personal Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>