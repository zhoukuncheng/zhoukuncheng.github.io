<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编程 | zhoukuncheng's Personal Blog</title>
<meta name=keywords content><meta name=description content="zhoukuncheng's Personal Blog"><meta name=author content><link rel=canonical href=https://zhoukuncheng.github.io/categories/%E7%BC%96%E7%A8%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zhoukuncheng.github.io/categories/%E7%BC%96%E7%A8%8B/index.xml><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/categories/%E7%BC%96%E7%A8%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="编程"><meta property="og:description" content="zhoukuncheng's Personal Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://zhoukuncheng.github.io/categories/%E7%BC%96%E7%A8%8B/"><meta name=twitter:card content="summary"><meta name=twitter:title content="编程"><meta name=twitter:description content="zhoukuncheng's Personal Blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zhoukuncheng.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoukuncheng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoukuncheng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoukuncheng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>编程</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Structured concurrency</h2></header><div class=entry-content><p>简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming. The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure’s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated. Structured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines. 简单来说：结构化并发（Structu...</p></div><footer class=entry-footer><span title='2022-08-01 23:54:05 +0800 +0800'>August 1, 2022</span></footer><a class=entry-link aria-label="post link to Structured concurrency" href=https://zhoukuncheng.github.io/posts/structured-concurrency/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Go 1.18 泛型介绍</h2></header><div class=entry-content><p>什么是泛型 泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。 Golang 泛型基本用法 示例 map 操作 package main import ( "fmt" ) func mapFunc[T any, M any](a []T, f func(T) M) []M { n := make([]M, len(a), cap(a)) for i, e := range a { n[i] = f(e) } return n } func main() { vi := []int{1, 2, 3, 4, 5, 6} vs := mapFunc(vi, func(v int) string { return "&lt;" + fmt.Sprint(v * v) + ">" }) fmt.Println(vs) } min max 函数 package main import ( "fmt" ) type ordered interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |...</p></div><footer class=entry-footer><span title='2022-03-16 22:41:56 +0800 +0800'>March 16, 2022</span></footer><a class=entry-link aria-label="post link to Go 1.18 泛型介绍" href=https://zhoukuncheng.github.io/posts/go-generics/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>通过 gRPC-Gateway 开发 RESTful API</h2></header><div class=entry-content><p>gRPC-Gateway 简介 gRPC-Gateway 是 protoc 的一个插件，工作机制是读取一个 gRPC 服务定义并生成一个反向代理服务器，将 RESTful JSON API 翻译成 gRPC。 这个服务器是根据编写的 gRPC 定义中的自定义选项来生成的。 安装使用 依赖工具 工具 简介 安装 protobuf protocol buffer 编译所需的命令行 http://google.github.io/proto-lens/installing-protoc.html protoc-gen-go 从 proto 文件，生成 .go 文件 https://grpc.io/docs/languages/go/quickstart/ protoc-gen-go-grpc 从 proto 文件，生成 gRPC 相关的 .go 文件 https://grpc.io/docs/languages/go/quickstart/ protoc-gen-grpc-gateway 从 proto 文件，生成 gRPC-gateway 相关的 .go 文件 https://github.com/grpc-ecosystem/grpc-gateway#installation protoc-gen-openapiv2 从 proto 文件，生成 swagger 文档所需的参数文件 https://github.com/grpc-ecosystem/grpc-gateway#installation buf protobuf 管理工具，可选，简化命令行操作和protobuf 文件管理 https://docs.buf.build/installation 步骤 编...</p></div><footer class=entry-footer><span title='2022-03-13 18:13:14 +0800 +0800'>March 13, 2022</span></footer><a class=entry-link aria-label="post link to 通过 gRPC-Gateway 开发 RESTful API" href=https://zhoukuncheng.github.io/posts/go-grpc-gateway/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Python 与 Go 之间的并发模式差异</h2></header><div class=entry-content><p>Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。 进程 多进程编程示例： from multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。 但需要注意，创建进程的参数...</p></div><footer class=entry-footer><span title='2021-08-30 23:54:05 +0800 +0800'>August 30, 2021</span></footer><a class=entry-link aria-label="post link to Python 与 Go 之间的并发模式差异" href=https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>编译 CPython 心得</h2></header><div class=entry-content><p>什么情况下需要自己编译 CPython 大多数操作系统都提供了编译好的 CPython 版本，一般直接通过包管理器安装就能满足需求，但是某些情况下，就需要自己编译 CPython 来满足特定需求了： 操作系统提供的 Python 版本太低，并且 Python 官网、系统包管理源没有提供预编译的新版本 Python 预编译版本不符合性能、扩展等方面的要求，比如没有开启编译器优化、OpenSSL/SQLite 版本不满足要求等 参与 CPython 开发或者尝鲜，尝试 Alpha/Beta/RC 等版本的 Python ​ ​ 低版本 Linux 发行版上编译 CPython 时的注...</p></div><footer class=entry-footer><span title='2020-07-24 01:11:34 +0800 +0800'>July 24, 2020</span></footer><a class=entry-link aria-label="post link to 编译  CPython 心得 " href=https://zhoukuncheng.github.io/posts/python-build/></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://zhoukuncheng.github.io/>zhoukuncheng's Personal Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>