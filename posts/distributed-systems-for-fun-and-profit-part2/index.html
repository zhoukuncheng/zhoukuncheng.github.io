<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Notes on 'Distributed Systems for Fun and Profit' (Part 2) | zhoukuncheng's Personal Blog</title><meta name=keywords content="Distributed Systems"><meta name=description content="2. Abstractions at Different Levels
System Model
Programs in distributed systems:

Run concurrently on independent nodes
Communicate via network connections that may introduce uncertainty and message loss
Have no shared memory or shared clock

The system model enumerates many assumptions related to specific system designs, covering the environment and facilities where the distributed system is implemented:

What capabilities nodes have and how they fail
How communication links operate and how they might fail
Properties of the overall system, such as assumptions about time and order

A robust system model makes the weakest assumptions, while strong assumptions create system models that are easier to reason about."><meta name=author content="zhoukuncheng"><link rel=canonical href=https://zhoukuncheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://zhoukuncheng.github.io/zh/posts/distributed-systems-for-fun-and-profit-part2/><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GH88YSLNJN"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GH88YSLNJN")}</script><meta property="og:url" content="https://zhoukuncheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/"><meta property="og:site_name" content="zhoukuncheng's Personal Blog"><meta property="og:title" content="Notes on 'Distributed Systems for Fun and Profit' (Part 2)"><meta property="og:description" content="2. Abstractions at Different Levels System Model Programs in distributed systems:
Run concurrently on independent nodes Communicate via network connections that may introduce uncertainty and message loss Have no shared memory or shared clock The system model enumerates many assumptions related to specific system designs, covering the environment and facilities where the distributed system is implemented:
What capabilities nodes have and how they fail How communication links operate and how they might fail Properties of the overall system, such as assumptions about time and order A robust system model makes the weakest assumptions, while strong assumptions create system models that are easier to reason about."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-15T09:22:15+08:00"><meta property="article:modified_time" content="2020-09-15T09:22:15+08:00"><meta property="article:tag" content="Distributed Systems"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes on 'Distributed Systems for Fun and Profit' (Part 2)"><meta name=twitter:description content="2. Abstractions at Different Levels
System Model
Programs in distributed systems:

Run concurrently on independent nodes
Communicate via network connections that may introduce uncertainty and message loss
Have no shared memory or shared clock

The system model enumerates many assumptions related to specific system designs, covering the environment and facilities where the distributed system is implemented:

What capabilities nodes have and how they fail
How communication links operate and how they might fail
Properties of the overall system, such as assumptions about time and order

A robust system model makes the weakest assumptions, while strong assumptions create system models that are easier to reason about."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Notes on 'Distributed Systems for Fun and Profit' (Part 2)","item":"https://zhoukuncheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Notes on 'Distributed Systems for Fun and Profit' (Part 2)","name":"Notes on \u0027Distributed Systems for Fun and Profit\u0027 (Part 2)","description":"2. Abstractions at Different Levels System Model Programs in distributed systems:\nRun concurrently on independent nodes Communicate via network connections that may introduce uncertainty and message loss Have no shared memory or shared clock The system model enumerates many assumptions related to specific system designs, covering the environment and facilities where the distributed system is implemented:\nWhat capabilities nodes have and how they fail How communication links operate and how they might fail Properties of the overall system, such as assumptions about time and order A robust system model makes the weakest assumptions, while strong assumptions create system models that are easier to reason about.\n","keywords":["Distributed Systems"],"articleBody":"2. Abstractions at Different Levels System Model Programs in distributed systems:\nRun concurrently on independent nodes Communicate via network connections that may introduce uncertainty and message loss Have no shared memory or shared clock The system model enumerates many assumptions related to specific system designs, covering the environment and facilities where the distributed system is implemented:\nWhat capabilities nodes have and how they fail How communication links operate and how they might fail Properties of the overall system, such as assumptions about time and order A robust system model makes the weakest assumptions, while strong assumptions create system models that are easier to reason about.\nNodes in this Model As hosts for computation and storage:\nAbility to execute programs Ability to store data into memory and stable persistent state Have a clock Nodes execute deterministic algorithms.\nFailure model: Crash-recovery rather than Byzantine fault tolerance (arbitrary errors).\nCommunication Links in this Model Communication links connect nodes to each other and send messages in either direction.\nThe network is unreliable; messages are prone to delay and loss.\nNetwork partition: The network is disconnected but nodes are alive.\nAssumptions about Time and Order Information travels at most at the speed of light.\nIf distances vary, the arrival time and order of messages between nodes may vary.\nSynchronous System Model Processes execute in lock-step; message transmission delay has a known upper bound; every process has an accurate clock.\nAsynchronous System Model No timing assumptions; processes execute at independent rates; message transmission delay implies no bound; useful clocks do not exist.\nConsensus Problem Consensus is reached when multiple nodes agree on some value.\nAgreement: Every correct node agrees on the same value. Integrity: Every correct process decides at most one value, and if it decides some value, then it must have been proposed by some process. Termination: All processes eventually reach a decision. Validity: If all correct processes propose the same value V, then all correct processes decide value V. Two Impossible Results FLP Impossibility Assuming nodes can only fail by crashing; network is reliable, and typical timing assumptions of asynchronous system models hold: e.g., message delay has no bound.\nIn a minimal asynchronous model system where the network is reliable but nodes are allowed to fail (even just one), there is no deterministic consensus algorithm that can solve the consensus problem.\nCAP Theorem Three properties:\n(Strong) Consistency: All nodes see the same data at the same time. Availability: Node failures do not prevent survivors from continuing to operate. Partition Tolerance: The system continues to operate despite message loss due to network or node failure. A system possessing all three properties simultaneously is impossible to achieve.\nThree different system types:\nCA (Consistency + Availability): Fully strict quorum protocols, e.g., Two-Phase Commit. CP (Consistency + Partition Tolerance): Majority quorum protocols where a minority partition is unavailable, e.g., Paxos. AP (Availability + Partition Tolerance): Protocols using conflict resolution, e.g., Dynamo. Consistency Model: A contract between the programmer and the system, where the system guarantees that if the programmer follows specific rules, the results of operations on the data store will be predictable.\nStrong Consistency Models (Able to maintain a single copy) Linearizable consistency Sequential consistency Weak Consistency Client-centric consistency models Causal consistency: strongest model available Eventual consistency models Linearizable consistency requires that the order in which operations take effect equals the actual real-time order of operations. Sequential consistency allows operations to be reordered, as long as the order observed on every node remains consistent.\n","wordCount":"577","inLanguage":"en","datePublished":"2020-09-15T09:22:15+08:00","dateModified":"2020-09-15T09:22:15+08:00","author":{"@type":"Person","name":"zhoukuncheng"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://zhoukuncheng.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zhoukuncheng.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoukuncheng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoukuncheng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoukuncheng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Notes on 'Distributed Systems for Fun and Profit' (Part 2)</h1><div class=post-meta><span title='2020-09-15 09:22:15 +0800 +0800'>September 15, 2020</span>&nbsp;·&nbsp;<span>zhoukuncheng</span>&nbsp;|&nbsp;<span>Translations:</span><ul class=i18n_list><li><a href=https://zhoukuncheng.github.io/zh/posts/distributed-systems-for-fun-and-profit-part2/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#2-abstractions-at-different-levels aria-label="2. Abstractions at Different Levels">2. Abstractions at Different Levels</a><ul><li><a href=#system-model aria-label="System Model">System Model</a><ul><li><a href=#nodes-in-this-model aria-label="Nodes in this Model">Nodes in this Model</a></li><li><a href=#communication-links-in-this-model aria-label="Communication Links in this Model">Communication Links in this Model</a></li><li><a href=#assumptions-about-time-and-order aria-label="Assumptions about Time and Order">Assumptions about Time and Order</a><ul><li><a href=#synchronous-system-model aria-label="Synchronous System Model">Synchronous System Model</a></li><li><a href=#asynchronous-system-model aria-label="Asynchronous System Model">Asynchronous System Model</a></li></ul></li><li><a href=#consensus-problem aria-label="Consensus Problem">Consensus Problem</a></li></ul></li><li><a href=#two-impossible-results aria-label="Two Impossible Results">Two Impossible Results</a><ul><li><a href=#flp-impossibility aria-label="FLP Impossibility">FLP Impossibility</a></li><li><a href=#cap-theorem aria-label="CAP Theorem">CAP Theorem</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=2-abstractions-at-different-levels>2. Abstractions at Different Levels<a hidden class=anchor aria-hidden=true href=#2-abstractions-at-different-levels>#</a></h2><h3 id=system-model>System Model<a hidden class=anchor aria-hidden=true href=#system-model>#</a></h3><p>Programs in distributed systems:</p><ul><li>Run concurrently on independent nodes</li><li>Communicate via network connections that may introduce uncertainty and message loss</li><li>Have no shared memory or shared clock</li></ul><p>The system model enumerates many assumptions related to specific system designs, covering the environment and facilities where the distributed system is implemented:</p><ul><li>What capabilities nodes have and how they fail</li><li>How communication links operate and how they might fail</li><li>Properties of the overall system, such as assumptions about time and order</li></ul><p>A robust system model makes the weakest assumptions, while strong assumptions create system models that are easier to reason about.</p><h4 id=nodes-in-this-model>Nodes in this Model<a hidden class=anchor aria-hidden=true href=#nodes-in-this-model>#</a></h4><p>As hosts for computation and storage:</p><ul><li>Ability to execute programs</li><li>Ability to store data into memory and stable persistent state</li><li>Have a clock</li></ul><p>Nodes execute deterministic algorithms.</p><p>Failure model: Crash-recovery rather than Byzantine fault tolerance (arbitrary errors).</p><h4 id=communication-links-in-this-model>Communication Links in this Model<a hidden class=anchor aria-hidden=true href=#communication-links-in-this-model>#</a></h4><p>Communication links connect nodes to each other and send messages in either direction.</p><p>The network is unreliable; messages are prone to delay and loss.</p><p>Network partition: The network is disconnected but nodes are alive.</p><h4 id=assumptions-about-time-and-order>Assumptions about Time and Order<a hidden class=anchor aria-hidden=true href=#assumptions-about-time-and-order>#</a></h4><p>Information travels at most at the speed of light.</p><p>If distances vary, the arrival time and order of messages between nodes may vary.</p><h5 id=synchronous-system-model>Synchronous System Model<a hidden class=anchor aria-hidden=true href=#synchronous-system-model>#</a></h5><p>Processes execute in lock-step; message transmission delay has a known upper bound; every process has an accurate clock.</p><h5 id=asynchronous-system-model>Asynchronous System Model<a hidden class=anchor aria-hidden=true href=#asynchronous-system-model>#</a></h5><p>No timing assumptions; processes execute at independent rates; message transmission delay implies no bound; useful clocks do not exist.</p><h4 id=consensus-problem>Consensus Problem<a hidden class=anchor aria-hidden=true href=#consensus-problem>#</a></h4><p>Consensus is reached when multiple nodes agree on some value.</p><ol><li>Agreement: Every correct node agrees on the same value.</li><li>Integrity: Every correct process decides at most one value, and if it decides some value, then it must have been proposed by some process.</li><li>Termination: All processes eventually reach a decision.</li><li>Validity: If all correct processes propose the same value V, then all correct processes decide value V.</li></ol><h3 id=two-impossible-results>Two Impossible Results<a hidden class=anchor aria-hidden=true href=#two-impossible-results>#</a></h3><h4 id=flp-impossibility>FLP Impossibility<a hidden class=anchor aria-hidden=true href=#flp-impossibility>#</a></h4><p>Assuming nodes can only fail by crashing; network is reliable, and typical timing assumptions of asynchronous system models hold: e.g., message delay has no bound.</p><p>In a minimal asynchronous model system where the network is reliable but nodes are allowed to fail (even just one), there is no deterministic consensus algorithm that can solve the consensus problem.</p><h4 id=cap-theorem>CAP Theorem<a hidden class=anchor aria-hidden=true href=#cap-theorem>#</a></h4><p>Three properties:</p><ul><li>(Strong) Consistency: All nodes see the same data at the same time.</li><li>Availability: Node failures do not prevent survivors from continuing to operate.</li><li>Partition Tolerance: The system continues to operate despite message loss due to network or node failure.</li></ul><p><img loading=lazy src=/static/CAP.png></p><p>A system possessing all three properties simultaneously is impossible to achieve.</p><p>Three different system types:</p><ul><li>CA (Consistency + Availability): Fully strict quorum protocols, e.g., Two-Phase Commit.</li><li>CP (Consistency + Partition Tolerance): Majority quorum protocols where a minority partition is unavailable, e.g., Paxos.</li><li>AP (Availability + Partition Tolerance): Protocols using conflict resolution, e.g., Dynamo.</li></ul><p><img loading=lazy src=/static/CAP_choice.png></p><p>Consistency Model: A contract between the programmer and the system, where the system guarantees that if the programmer follows specific rules, the results of operations on the data store will be predictable.</p><ul><li>Strong Consistency Models (Able to maintain a single copy)<ul><li>Linearizable consistency</li><li>Sequential consistency</li></ul></li><li>Weak Consistency<ul><li>Client-centric consistency models</li><li>Causal consistency: strongest model available</li><li>Eventual consistency models</li></ul></li></ul><p>Linearizable consistency requires that the order in which operations take effect equals the actual real-time order of operations. Sequential consistency allows operations to be reordered, as long as the order observed on every node remains consistent.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/tags/distributed-systems/>Distributed Systems</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=purple_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://zhoukuncheng.github.io/>zhoukuncheng's Personal Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>