<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Structured concurrency | zhoukuncheng's Personal Blog</title>
<meta name=keywords content="Golang,Concurrency"><meta name=description content="简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming. The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure&rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated. Structured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines. 简单来说：结构化并发（Structu"><meta name=author content><link rel=canonical href=https://zhoukuncheng.github.io/posts/structured-concurrency/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/structured-concurrency/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Structured concurrency"><meta property="og:description" content="简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming. The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure&rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated. Structured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines. 简单来说：结构化并发（Structu"><meta property="og:type" content="article"><meta property="og:url" content="https://zhoukuncheng.github.io/posts/structured-concurrency/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-01T23:54:05+08:00"><meta property="article:modified_time" content="2022-08-01T23:54:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Structured concurrency"><meta name=twitter:description content="简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming. The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure&rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated. Structured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines. 简单来说：结构化并发（Structu"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Structured concurrency","item":"https://zhoukuncheng.github.io/posts/structured-concurrency/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Structured concurrency","name":"Structured concurrency","description":"简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming. The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure\u0026rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated. Structured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines. 简单来说：结构化并发（Structu","keywords":["Golang","Concurrency"],"articleBody":"简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming.\nThe core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure’s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated.\nStructured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines.\n简单来说：结构化并发（Structured Concurrency） 就是类似 结构化编程 的一个术语，目的是提高并发编程的可读性、可控制性，也就是提高开发体验和并发编程的代码质量。\n基本概念是封装线程的执行，让它们有清晰的进入和退出点，并且所有线程都在退出前完成。\n其中封装的手段，还包括把线程中产生的错误，委托到父级范围处理。\n而且就算使用并发，控制流结构在源代码中依然清晰可读。\n结构化编程 vs goto 结构化编程：使用代码块封装基本的控制流，包括常见的条件语句、循环语句以及函数调用。 goto: 不加限制的跳转。\n图示 背景 发展过程 2016 年，ZeroMQ 的作者 Martin Sústrik 在他的 文章 中第一次形式化的提出结构化并发这个概念。\n2018 年 Nathaniel J. Smith 在 Python 中实现了这一范式 - trio，并在 Notes on structured concurrency, or: Go statement considered harmful 一文中进一步阐述了 Structured Concurrency。\n同时期，Roman Elizarov 也提出了相同的理念，并在 Kotlin 中实现了大家熟知的kotlinx.coroutine。\n2019 年，OpenJDK loom project 也开始引入 structured concurrency，作为其轻量级线程和协程的一部分。在 Java 19 中会包含此功能。\n2022 年，Python 3.11 引入 task group 和 exception group，官方支持了结构化并发。\n另外，Swift、Rust 等较新的编程语言，也有官方或第三方库，实现了 Structured Concurrency。\n示例 import asyncio import httpx client = httpx.AsyncClient() async def run(): r = await client.get(\"http://127.0.0.1:8000\", timeout=3) print(r.text) async def main(): async with asyncio.timeout(1): async with asyncio.TaskGroup() as tg: for i in range(2): tg.create_task(run()) print(\"all tasks have completed now.\") asyncio.run(main()) Traceback (most recent call last): File \"C:\\Users\\jack\\PycharmProjects\\demo\\main.py\", line 14, in main async with asyncio.TaskGroup() as tg: File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\taskgroups.py\", line 121, in __aexit__ raise propagate_cancellation_error File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\taskgroups.py\", line 96, in __aexit__ await self._on_completed_fut asyncio.exceptions.CancelledError During handling of the above exception, another exception occurred: Traceback (most recent call last): File \"C:\\Users\\jack\\PycharmProjects\\demo\\main.py\", line 20, in asyncio.run(main()) File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\runners.py\", line 187, in run return runner.run(main) ^^^^^^^^^^^^^^^^ File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\runners.py\", line 120, in run return self._loop.run_until_complete(task) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\base_events.py\", line 650, in run_until_complete return future.result() ^^^^^^^^^^^^^^^ File \"C:\\Users\\jack\\PycharmProjects\\demo\\main.py\", line 13, in main async with asyncio.timeout(1): File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\timeouts.py\", line 98, in __aexit__ raise TimeoutError TimeoutError Process finished with exit code 1 Go 中的提案 有人给 Go 官方提了一个 # proposal: Go 2: use structured concurrency #29011, 不过根据ianlancetaylor 等 Go 社区贡献者的意见，这个提案可能会对已有的 Go 代码造成兼容性问题，以及当前 Go 标准库中已经有 context.Context、sync.WaitGroup 、x/sync/errgroup 等工具，这个提案最终没有被接受。\n在 Go 中如何实践 Structured Concurrency 并发编程需要考虑的问题 这个任务什么时候开始，什么时候结束？ 怎么做到当所有子任务都结束，主任务再结束？ 假如某个子任务失败，主任务如何取消掉其他剩下子任务？ 如何保证所有子任务在某个特定的超时时间内返回，无论它成功还是失败？ 更进一步，如何保证主任务在规定的时间内返回，无论其成功还是失败，同时取消掉它产生的所有子任务？ 主任务已经结束了，子任务还在执行，是不是存在资源泄漏？ Go 中的解决方案 channel context waitgroup errgroup 例一：errgroup 链接\npackage main import ( \"context\" \"crypto/md5\" \"fmt\" \"io/ioutil\" \"log\" \"os\" \"path/filepath\" \"golang.org/x/sync/errgroup\" ) // Pipeline demonstrates the use of a Group to implement a multi-stage // pipeline: a version of the MD5All function with bounded parallelism from // https://blog.golang.org/pipelines. func main() { m, err := MD5All(context.Background(), \".\") if err != nil { log.Fatal(err) } for k, sum := range m { fmt.Printf(\"%s:\\t%x\\n\", k, sum) } } type result struct { path string sum [md5.Size]byte } // MD5All reads all the files in the file tree rooted at root and returns a map // from file path to the MD5 sum of the file's contents. If the directory walk // fails or any read operation fails, MD5All returns an error. func MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) { // ctx is canceled when g.Wait() returns. When this version of MD5All returns // - even in case of error! - we know that all of the goroutines have finished // and the memory they were using can be garbage-collected. g, ctx := errgroup.WithContext(ctx) paths := make(chan string) g.Go(func() error { defer close(paths) return filepath.Walk(root, func(path string, info os.FileInfo, err error) error { if err != nil { return err } if !info.Mode().IsRegular() { return nil } select { case paths \u003c- path: case \u003c-ctx.Done(): return ctx.Err() } return nil }) }) // Start a fixed number of goroutines to read and digest files. c := make(chan result) const numDigesters = 20 for i := 0; i \u003c numDigesters; i++ { g.Go(func() error { for path := range paths { data, err := ioutil.ReadFile(path) if err != nil { return err } select { case c \u003c- result{path, md5.Sum(data)}: case \u003c-ctx.Done(): return ctx.Err() } } return nil }) } go func() { g.Wait() close(c) }() m := make(map[string][md5.Size]byte) for r := range c { m[r.path] = r.sum } // Check whether any of the goroutines failed. Since g is accumulating the // errors, we don't need to send them (or check for them) in the individual // results sent on the channel. if err := g.Wait(); err != nil { return nil, err } return m, nil } errgroup 源码分析 type Group struct { cancel func() // 封装context cancel 方法 wg sync.WaitGroup // 使用 waitGroup 同步 sem chan token // 使用 channel 限制数量 errOnce sync.Once // 只执行一次 err error // 保存执行的错误信息 } // Wait blocks until all function calls from the Go method have returned, then // returns the first non-nil error (if any) from them. func (g *Group) Wait() error { g.wg.Wait() if g.cancel != nil { g.cancel() } return g.err } // Go calls the given function in a new goroutine. // It blocks until the new goroutine can be added without the number of // active goroutines in the group exceeding the configured limit. // // The first call to return a non-nil error cancels the group; its error will be // returned by Wait. func (g *Group) Go(f func() error) { if g.sem != nil { g.sem \u003c- token{} } g.wg.Add(1) go func() { defer g.done() if err := f(); err != nil { g.errOnce.Do(func() { g.err = err if g.cancel != nil { g.cancel() } }) } }() } 例二：waitGroup https://github.com/arunsworld/nursery/blob/ecfe7a688cfd866de0da8ecff34de72b34d22f53/nursery.go\n参考与引用 https://en.wikipedia.org/wiki/Structured_concurrency\nhttp://250bpm.com/blog:71\nhttps://trio.readthedocs.io/en/stable/\nhttps://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/\nhttps://medium.com/@elizarov/structured-concurrency-722d765aa952\nhttps://kotlinlang.org/docs/coroutines-basics.html\nhttps://github.com/golang/go/issues/29011\nhttps://github.com/arunsworld/nursery/blob/master/nursery.go\nhttps://arunsworld.medium.com/structured-concurrency-in-go-b800c7c4434e\nhttps://realpython.com/python311-exception-groups/\nhttps://zhuanlan.zhihu.com/p/108759542\nhttps://onevcat.com/2021/09/structured-concurrency/\nhttps://blog.softwaremill.com/structured-concurrency-and-pure-functions-92dd8ed1a9f2\n","wordCount":"1820","inLanguage":"en","datePublished":"2022-08-01T23:54:05+08:00","dateModified":"2022-08-01T23:54:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/posts/structured-concurrency/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zhoukuncheng.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoukuncheng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoukuncheng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoukuncheng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Structured concurrency</h1><div class=post-meta><span title='2022-08-01 23:54:05 +0800 +0800'>August 1, 2022</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a><ul><li><a href=#%e5%ae%9a%e4%b9%89 aria-label=定义>定义</a><ul><li><a href=#%e7%bb%93%e6%9e%84%e5%8c%96%e7%bc%96%e7%a8%8b-vs-goto aria-label="结构化编程 vs goto">结构化编程 vs goto</a></li><li><a href=#%e5%9b%be%e7%a4%ba aria-label=图示>图示</a></li></ul></li><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a><ul><li><a href=#%e5%8f%91%e5%b1%95%e8%bf%87%e7%a8%8b aria-label=发展过程>发展过程</a></li></ul></li><li><a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a></li><li><a href=#go-%e4%b8%ad%e7%9a%84%e6%8f%90%e6%a1%88 aria-label="Go 中的提案">Go 中的提案</a></li></ul></li><li><a href=#%e5%9c%a8-go-%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e8%b7%b5-structured-concurrency aria-label="在 Go 中如何实践 Structured Concurrency">在 Go 中如何实践 Structured Concurrency</a><ul><li><a href=#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=并发编程需要考虑的问题>并发编程需要考虑的问题</a></li><li><a href=#go-%e4%b8%ad%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label="Go 中的解决方案">Go 中的解决方案</a><ul><ul><li><a href=#%e4%be%8b%e4%b8%80errgroup aria-label=例一：errgroup>例一：errgroup</a></li><li><a href=#errgroup-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label="errgroup 源码分析">errgroup 源码分析</a></li><li><a href=#%e4%be%8b%e4%ba%8cwaitgroup aria-label=例二：waitGroup>例二：waitGroup</a></li></ul></ul></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e4%b8%8e%e5%bc%95%e7%94%a8 aria-label=参考与引用>参考与引用</a></li></ul></div></details></div><div class=post-content><h1 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h1><h2 id=定义>定义<a hidden class=anchor aria-hidden=true href=#定义>#</a></h2><p>根据维基百科的解释：
<strong>Structured concurrency</strong> is a <a href=https://en.wikipedia.org/wiki/Programming_paradigm title="Programming paradigm">programming paradigm</a> aimed at improving the <strong>clarity, quality, and development time</strong> of a <a href=https://en.wikipedia.org/wiki/Computer_program title="Computer program">computer program</a> by using a structured approach to <a href=https://en.wikipedia.org/wiki/Concurrent_computing title="Concurrent computing">concurrent programming</a>.</p><p>The core concept is the <strong>encapsulation of concurrent threads of execution</strong> (here encompassing kernel and userland threads and processes) by way of control flow constructs that have <strong>clear entry and exit points</strong> and that ensure <strong>all spawned threads have completed before exit</strong>. Such encapsulation allows <strong>errors in concurrent threads to be propagated to the control structure&rsquo;s parent scope</strong> and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model <strong>must be applied consistently throughout all levels of the program</strong> – otherwise <strong>concurrent threads may leak out</strong>, become orphaned, or fail to have runtime errors correctly propagated.</p><p>Structured concurrency is analogous to <a href=https://en.wikipedia.org/wiki/Structured_programming title="Structured programming">structured programming</a>, which introduced control flow constructs that encapsulated sequential statements and subroutines.</p><p>简单来说：<strong>结构化并发（Structured Concurrency）</strong> 就是类似 <strong>结构化编程</strong> 的一个术语，目的是提高并发编程的可读性、可控制性，也就是提高开发体验和并发编程的代码质量。<br>基本概念是封装线程的执行，让它们有清晰的进入和退出点，并且所有线程都在退出前完成。<br>其中封装的手段，还包括把线程中产生的错误，委托到父级范围处理。<br>而且就算使用并发，控制流结构在源代码中依然清晰可读。</p><hr><h3 id=结构化编程-vs-goto>结构化编程 vs goto<a hidden class=anchor aria-hidden=true href=#结构化编程-vs-goto>#</a></h3><p>结构化编程：使用代码块封装基本的控制流，包括常见的条件语句、循环语句以及函数调用。
<img loading=lazy src=/static/Pastedimage20220731221808.png alt></p><p>goto: 不加限制的跳转。<br><img loading=lazy src=/static/Pastedimage20220731221638.png alt></p><hr><h3 id=图示>图示<a hidden class=anchor aria-hidden=true href=#图示>#</a></h3><p><img loading=lazy src=/static/Pastedimage20220731222204.png alt><br><img loading=lazy src=/static/Pastedimage20220731223832.png alt></p><hr><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><h3 id=发展过程>发展过程<a hidden class=anchor aria-hidden=true href=#发展过程>#</a></h3><p>2016 年，ZeroMQ 的作者 Martin Sústrik 在他的 <a href=http://250bpm.com/blog:71>文章</a> 中第一次形式化的提出结构化并发这个概念。<br>2018 年 Nathaniel J. Smith 在 Python 中实现了这一范式 - <a href=https://trio.readthedocs.io/en/stable/>trio</a>，并在 <a href=https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/>Notes on structured concurrency, or: Go statement considered harmful</a> 一文中进一步阐述了 Structured Concurrency。<br>同时期，Roman Elizarov 也提出了相同的<a href=https://elizarov.medium.com/structured-concurrency-722d765aa952>理念</a>，并在 Kotlin 中实现了大家熟知的<a href=https://kotlinlang.org/docs/coroutines-basics.html>kotlinx.coroutine</a>。<br>2019 年，OpenJDK loom project 也开始引入 <a href=https://openjdk.org/jeps/428>structured concurrency</a>，作为其轻量级线程和协程的一部分。在 Java 19 中会包含此功能。<br>2022 年，Python 3.11 引入 <a href=https://realpython.com/python311-exception-groups/>task group 和 exception group</a>，官方支持了结构化并发。<br>另外，Swift、Rust 等较新的编程语言，也有官方或第三方库，实现了 Structured Concurrency。</p><hr><h2 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>  
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>httpx</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>client</span> <span class=o>=</span> <span class=n>httpx</span><span class=o>.</span><span class=n>AsyncClient</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>run</span><span class=p>():</span>  
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=k>await</span> <span class=n>client</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;http://127.0.0.1:8000&#34;</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>text</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>  
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>with</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>timeout</span><span class=p>(</span><span class=mi>1</span><span class=p>):</span>  
</span></span><span class=line><span class=cl>        <span class=k>async</span> <span class=k>with</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>TaskGroup</span><span class=p>()</span> <span class=k>as</span> <span class=n>tg</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>):</span>  
</span></span><span class=line><span class=cl>                <span class=n>tg</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>run</span><span class=p>())</span>  
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;all tasks have completed now.&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Traceback (most recent call last):
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\PycharmProjects\demo\main.py&#34;, line 14, in main
</span></span><span class=line><span class=cl>    async with asyncio.TaskGroup() as tg:
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\taskgroups.py&#34;, line 121, in __aexit__
</span></span><span class=line><span class=cl>    raise propagate_cancellation_error
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\taskgroups.py&#34;, line 96, in __aexit__
</span></span><span class=line><span class=cl>    await self._on_completed_fut
</span></span><span class=line><span class=cl>asyncio.exceptions.CancelledError
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>During handling of the above exception, another exception occurred:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Traceback (most recent call last):
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\PycharmProjects\demo\main.py&#34;, line 20, in &lt;module&gt;
</span></span><span class=line><span class=cl>    asyncio.run(main())
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\runners.py&#34;, line 187, in run
</span></span><span class=line><span class=cl>    return runner.run(main)
</span></span><span class=line><span class=cl>           ^^^^^^^^^^^^^^^^
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\runners.py&#34;, line 120, in run
</span></span><span class=line><span class=cl>    return self._loop.run_until_complete(task)
</span></span><span class=line><span class=cl>           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\base_events.py&#34;, line 650, in run_until_complete
</span></span><span class=line><span class=cl>    return future.result()
</span></span><span class=line><span class=cl>           ^^^^^^^^^^^^^^^
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\PycharmProjects\demo\main.py&#34;, line 13, in main
</span></span><span class=line><span class=cl>    async with asyncio.timeout(1):
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\timeouts.py&#34;, line 98, in __aexit__
</span></span><span class=line><span class=cl>    raise TimeoutError
</span></span><span class=line><span class=cl>TimeoutError
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Process finished with exit code 1
</span></span></code></pre></div><hr><h2 id=go-中的提案>Go 中的提案<a hidden class=anchor aria-hidden=true href=#go-中的提案>#</a></h2><p>有人给 Go 官方提了一个 <a href=https://github.com/golang/go/issues/29011># proposal: Go 2: use structured concurrency #29011</a>, 不过根据ianlancetaylor 等 Go 社区贡献者的意见，这个提案可能会对已有的 Go 代码造成兼容性问题，以及当前 Go 标准库中已经有 <code>context.Context</code>、<code>sync.WaitGroup</code> 、<code>x/sync/errgroup</code> 等工具，这个提案最终没有被接受。</p><hr><h1 id=在-go-中如何实践-structured-concurrency>在 Go 中如何实践 Structured Concurrency<a hidden class=anchor aria-hidden=true href=#在-go-中如何实践-structured-concurrency>#</a></h1><h2 id=并发编程需要考虑的问题>并发编程需要考虑的问题<a hidden class=anchor aria-hidden=true href=#并发编程需要考虑的问题>#</a></h2><ul><li>这个任务什么时候<strong>开始</strong>，什么时候<strong>结束</strong>？</li><li>怎么做到当所有<strong>子任务都结束</strong>，主任务再结束？</li><li>假如某个子任务失败，主任务如何<strong>取消</strong>掉其他剩下子任务？</li><li>如何保证所有子任务在某个特定的<strong>超时时间</strong>内返回，无论它成功还是失败？</li><li>更进一步，如何保证主任务在<strong>规定的时间</strong>内返回，无论其成功还是失败，同时<strong>取消</strong>掉它产生的所有子任务？</li><li>主任务已经结束了，子任务还在执行，是不是存在资源泄漏？</li></ul><hr><h2 id=go-中的解决方案>Go 中的解决方案<a hidden class=anchor aria-hidden=true href=#go-中的解决方案>#</a></h2><ul><li>channel</li><li>context</li><li>waitgroup</li><li>errgroup</li></ul><h4 id=例一errgroup>例一：errgroup<a hidden class=anchor aria-hidden=true href=#例一errgroup>#</a></h4><p><a href=https://pkg.go.dev/golang.org/x/sync/errgroup>链接</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;crypto/md5&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;io/ioutil&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;path/filepath&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;golang.org/x/sync/errgroup&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Pipeline demonstrates the use of a Group to implement a multi-stage
</span></span></span><span class=line><span class=cl><span class=c1>// pipeline: a version of the MD5All function with bounded parallelism from
</span></span></span><span class=line><span class=cl><span class=c1>// https://blog.golang.org/pipelines.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>MD5All</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>sum</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s:\t%x\n&#34;</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>result</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>path</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>sum</span>  <span class=p>[</span><span class=nx>md5</span><span class=p>.</span><span class=nx>Size</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// MD5All reads all the files in the file tree rooted at root and returns a map
</span></span></span><span class=line><span class=cl><span class=c1>// from file path to the MD5 sum of the file&#39;s contents. If the directory walk
</span></span></span><span class=line><span class=cl><span class=c1>// fails or any read operation fails, MD5All returns an error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>MD5All</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>root</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][</span><span class=nx>md5</span><span class=p>.</span><span class=nx>Size</span><span class=p>]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ctx is canceled when g.Wait() returns. When this version of MD5All returns
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// - even in case of error! - we know that all of the goroutines have finished
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and the memory they were using can be garbage-collected.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>g</span><span class=p>,</span> <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>errgroup</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>paths</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>paths</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Walk</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>info</span> <span class=nx>os</span><span class=p>.</span><span class=nx>FileInfo</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>info</span><span class=p>.</span><span class=nf>Mode</span><span class=p>().</span><span class=nf>IsRegular</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>paths</span> <span class=o>&lt;-</span> <span class=nx>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Start a fixed number of goroutines to read and digest files.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>const</span> <span class=nx>numDigesters</span> <span class=p>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>numDigesters</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>path</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>paths</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>result</span><span class=p>{</span><span class=nx>path</span><span class=p>,</span> <span class=nx>md5</span><span class=p>.</span><span class=nf>Sum</span><span class=p>(</span><span class=nx>data</span><span class=p>)}:</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][</span><span class=nx>md5</span><span class=p>.</span><span class=nx>Size</span><span class=p>]</span><span class=kt>byte</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>m</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>path</span><span class=p>]</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>sum</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Check whether any of the goroutines failed. Since g is accumulating the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// errors, we don&#39;t need to send them (or check for them) in the individual
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// results sent on the channel.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>Wait</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=errgroup-源码分析>errgroup 源码分析<a hidden class=anchor aria-hidden=true href=#errgroup-源码分析>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Group</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cancel</span> <span class=kd>func</span><span class=p>()</span>       <span class=c1>// 封装context cancel 方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>   <span class=c1>// 使用 waitGroup 同步
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sem</span> <span class=kd>chan</span> <span class=nx>token</span>      <span class=c1>// 使用 channel 限制数量
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>errOnce</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>   <span class=c1>// 只执行一次
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>err</span>     <span class=kt>error</span>       <span class=c1>// 保存执行的错误信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Wait blocks until all function calls from the Go method have returned, then
</span></span></span><span class=line><span class=cl><span class=c1>// returns the first non-nil error (if any) from them.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Group</span><span class=p>)</span> <span class=nf>Wait</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>cancel</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span><span class=p>.</span><span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>g</span><span class=p>.</span><span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Go calls the given function in a new goroutine.
</span></span></span><span class=line><span class=cl><span class=c1>// It blocks until the new goroutine can be added without the number of
</span></span></span><span class=line><span class=cl><span class=c1>// active goroutines in the group exceeding the configured limit.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// The first call to return a non-nil error cancels the group; its error will be
</span></span></span><span class=line><span class=cl><span class=c1>// returned by Wait.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Group</span><span class=p>)</span> <span class=nf>Go</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>sem</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span><span class=p>.</span><span class=nx>sem</span> <span class=o>&lt;-</span> <span class=nx>token</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>g</span><span class=p>.</span><span class=nf>done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>f</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>g</span><span class=p>.</span><span class=nx>errOnce</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>g</span><span class=p>.</span><span class=nx>err</span> <span class=p>=</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>cancel</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>g</span><span class=p>.</span><span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>})</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=例二waitgroup>例二：waitGroup<a hidden class=anchor aria-hidden=true href=#例二waitgroup>#</a></h4><p><a href=https://github.com/arunsworld/nursery/blob/ecfe7a688cfd866de0da8ecff34de72b34d22f53/nursery.go>https://github.com/arunsworld/nursery/blob/ecfe7a688cfd866de0da8ecff34de72b34d22f53/nursery.go</a></p><hr><h1 id=参考与引用>参考与引用<a hidden class=anchor aria-hidden=true href=#参考与引用>#</a></h1><p><a href=https://en.wikipedia.org/wiki/Structured_concurrency>https://en.wikipedia.org/wiki/Structured_concurrency</a><br><a href=http://250bpm.com/blog:71>http://250bpm.com/blog:71</a><br><a href=https://trio.readthedocs.io/en/stable/>https://trio.readthedocs.io/en/stable/</a><br><a href=https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/>https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/</a><br><a href=https://medium.com/@elizarov/structured-concurrency-722d765aa952>https://medium.com/@elizarov/structured-concurrency-722d765aa952</a><br><a href=https://kotlinlang.org/docs/coroutines-basics.html>https://kotlinlang.org/docs/coroutines-basics.html</a><br><a href=https://github.com/golang/go/issues/29011>https://github.com/golang/go/issues/29011</a><br><a href=https://github.com/arunsworld/nursery/blob/master/nursery.go>https://github.com/arunsworld/nursery/blob/master/nursery.go</a><br><a href=https://arunsworld.medium.com/structured-concurrency-in-go-b800c7c4434e>https://arunsworld.medium.com/structured-concurrency-in-go-b800c7c4434e</a><br><a href=https://realpython.com/python311-exception-groups/>https://realpython.com/python311-exception-groups/</a><br><a href=https://zhuanlan.zhihu.com/p/108759542>https://zhuanlan.zhihu.com/p/108759542</a><br><a href=https://onevcat.com/2021/09/structured-concurrency/>https://onevcat.com/2021/09/structured-concurrency/</a><br><a href=https://blog.softwaremill.com/structured-concurrency-and-pure-functions-92dd8ed1a9f2>https://blog.softwaremill.com/structured-concurrency-and-pure-functions-92dd8ed1a9f2</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/tags/golang/>Golang</a></li><li><a href=https://zhoukuncheng.github.io/tags/concurrency/>Concurrency</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=purple_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zhoukuncheng.github.io/>zhoukuncheng's Personal Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>