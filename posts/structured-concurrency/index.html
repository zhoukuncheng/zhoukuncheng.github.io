<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Structured Concurrency | zhoukuncheng's Personal Blog</title><meta name=keywords content="Golang,Concurrency"><meta name=description content="Introduction
Definition
According to Wikipedia:
Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming.
The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure&rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated."><meta name=author content="zhoukuncheng"><link rel=canonical href=https://zhoukuncheng.github.io/posts/structured-concurrency/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://zhoukuncheng.github.io/zh/posts/structured-concurrency/><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/structured-concurrency/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GH88YSLNJN"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GH88YSLNJN")}</script><meta property="og:url" content="https://zhoukuncheng.github.io/posts/structured-concurrency/"><meta property="og:site_name" content="zhoukuncheng's Personal Blog"><meta property="og:title" content="Structured Concurrency"><meta property="og:description" content="Introduction Definition According to Wikipedia:
Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming.
The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure’s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-01T23:54:05+08:00"><meta property="article:modified_time" content="2022-08-01T23:54:05+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Concurrency"><meta name=twitter:card content="summary"><meta name=twitter:title content="Structured Concurrency"><meta name=twitter:description content="Introduction
Definition
According to Wikipedia:
Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming.
The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure&rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Structured Concurrency","item":"https://zhoukuncheng.github.io/posts/structured-concurrency/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Structured Concurrency","name":"Structured Concurrency","description":"Introduction Definition According to Wikipedia:\nStructured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming.\nThe core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure\u0026rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated.\n","keywords":["Golang","Concurrency"],"articleBody":"Introduction Definition According to Wikipedia:\nStructured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming.\nThe core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure’s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated.\nStructured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines.\nIn short: Structured Concurrency is a term similar to Structured Programming, aimed at improving the readability and controllability of concurrent programming, i.e., improving the development experience and the quality of concurrent code.\nThe basic concept is to encapsulate the execution of threads, ensuring they have clear entry and exit points, and that all threads complete before exiting.\nThe means of encapsulation also includes delegating errors generated in threads to the parent scope for handling.\nMoreover, even with concurrency, the control flow structure remains clearly readable in the source code.\nStructured Programming vs goto Structured Programming: Uses code blocks to encapsulate basic control flow, including common conditional statements, loops, and function calls.\ngoto: Unrestricted jumps.\nIllustrations Background Development Process In 2016, ZeroMQ author Martin Sústrik formally proposed the concept of structured concurrency in his article.\nIn 2018, Nathaniel J. Smith implemented this paradigm in Python - trio, and further elaborated on Structured Concurrency in the article Notes on structured concurrency, or: Go statement considered harmful.\nAt the same time, Roman Elizarov also proposed the same idea, and implemented the well-known kotlinx.coroutine in Kotlin.\nIn 2019, OpenJDK loom project also began introducing structured concurrency as part of its lightweight threads and coroutines. It will be included in Java 19.\nIn 2022, Python 3.11 introduced task group and exception group, officially supporting structured concurrency.\nAdditionally, newer programming languages like Swift and Rust also have official or third-party libraries implementing Structured Concurrency.\nExample import asyncio import httpx client = httpx.AsyncClient() async def run(): r = await client.get(\"http://127.0.0.1:8000\", timeout=3) print(r.text) async def main(): async with asyncio.timeout(1): async with asyncio.TaskGroup() as tg: for i in range(2): tg.create_task(run()) print(\"all tasks have completed now.\") asyncio.run(main()) Traceback (most recent call last): File \"C:\\Users\\jack\\PycharmProjects\\demo\\main.py\", line 14, in main async with asyncio.TaskGroup() as tg: File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\taskgroups.py\", line 121, in __aexit__ raise propagate_cancellation_error File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\taskgroups.py\", line 96, in __aexit__ await self._on_completed_fut asyncio.exceptions.CancelledError During handling of the above exception, another exception occurred: Traceback (most recent call last): File \"C:\\Users\\jack\\PycharmProjects\\demo\\main.py\", line 20, in asyncio.run(main()) File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\runners.py\", line 187, in run return runner.run(main) ^^^^^^^^^^^^^^^^ File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\runners.py\", line 120, in run return self._loop.run_until_complete(task) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\base_events.py\", line 650, in run_until_complete return future.result() ^^^^^^^^^^^^^^^ File \"C:\\Users\\jack\\PycharmProjects\\demo\\main.py\", line 13, in main async with asyncio.timeout(1): File \"C:\\Users\\jack\\.pyenv\\pyenv-win\\versions\\3.11.0b4\\Lib\\asyncio\\timeouts.py\", line 98, in __aexit__ raise TimeoutError TimeoutError Process finished with exit code 1 Proposals in Go Someone proposed # proposal: Go 2: use structured concurrency #29011 to the official Go team. However, based on the opinions of Go community contributors like ianlancetaylor, this proposal might cause compatibility issues with existing Go code. Besides, the current Go standard library already has tools like context.Context, sync.WaitGroup, and x/sync/errgroup, so this proposal was ultimately not accepted.\nHow to Practice Structured Concurrency in Go Problems to Consider in Concurrent Programming When does this task start, and when does it end? How to ensure the main task ends only after all subtasks have completed? If a subtask fails, how does the main task cancel the remaining subtasks? How to ensure all subtasks return within a specific timeout, whether they succeed or fail? Furthermore, how to ensure the main task returns within a specified time, whether it succeeds or fails, while canceling all subtasks it spawned? If the main task has ended but subtasks are still running, is there a resource leak? Solutions in Go channel context waitgroup errgroup Example 1: errgroup Link\npackage main import ( \"context\" \"crypto/md5\" \"fmt\" \"io/ioutil\" \"log\" \"os\" \"path/filepath\" \"golang.org/x/sync/errgroup\" ) // Pipeline demonstrates the use of a Group to implement a multi-stage // pipeline: a version of the MD5All function with bounded parallelism from // https://blog.golang.org/pipelines. func main() { m, err := MD5All(context.Background(), \".\") if err != nil { log.Fatal(err) } for k, sum := range m { fmt.Printf(\"%s:\\t%x\\n\", k, sum) } } type result struct { path string sum [md5.Size]byte } // MD5All reads all the files in the file tree rooted at root and returns a map // from file path to the MD5 sum of the file's contents. If the directory walk // fails or any read operation fails, MD5All returns an error. func MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) { // ctx is canceled when g.Wait() returns. When this version of MD5All returns // - even in case of error! - we know that all of the goroutines have finished // and the memory they were using can be garbage-collected. g, ctx := errgroup.WithContext(ctx) paths := make(chan string) g.Go(func() error { defer close(paths) return filepath.Walk(root, func(path string, info os.FileInfo, err error) error { if err != nil { return err } if !info.Mode().IsRegular() { return nil } select { case paths \u003c- path: case \u003c-ctx.Done(): return ctx.Err() } return nil }) }) // Start a fixed number of goroutines to read and digest files. c := make(chan result) const numDigesters = 20 for i := 0; i \u003c numDigesters; i++ { g.Go(func() error { for path := range paths { data, err := ioutil.ReadFile(path) if err != nil { return err } select { case c \u003c- result{path, md5.Sum(data)}: case \u003c-ctx.Done(): return ctx.Err() } } return nil }) } go func() { g.Wait() close(c) }() m := make(map[string][md5.Size]byte) for r := range c { m[r.path] = r.sum } // Check whether any of the goroutines failed. Since g is accumulating the // errors, we don't need to send them (or check for them) in the individual // results sent on the channel. if err := g.Wait(); err != nil { return nil, err } return m, nil } errgroup Source Code Analysis type Group struct { cancel func() // Encapsulates context cancel method wg sync.WaitGroup // Uses waitGroup for synchronization sem chan token // Uses channel to limit number errOnce sync.Once // Ensures only executed once err error // Stores execution error message } // Wait blocks until all function calls from the Go method have returned, then // returns the first non-nil error (if any) from them. func (g *Group) Wait() error { g.wg.Wait() if g.cancel != nil { g.cancel() } return g.err } // Go calls the given function in a new goroutine. // It blocks until the new goroutine can be added without the number of // active goroutines in the group exceeding the configured limit. // // The first call to return a non-nil error cancels the group; its error will be // returned by Wait. func (g *Group) Go(f func() error) { if g.sem != nil { g.sem \u003c- token{} } g.wg.Add(1) go func() { defer g.done() if err := f(); err != nil { g.errOnce.Do(func() { g.err = err if g.cancel != nil { g.cancel() } }) } }() } Example 2: waitGroup https://github.com/arunsworld/nursery/blob/ecfe7a688cfd866de0da8ecff34de72b34d22f53/nursery.go\nReferences and Citations https://en.wikipedia.org/wiki/Structured_concurrency\nhttp://250bpm.com/blog:71\nhttps://trio.readthedocs.io/en/stable/\nhttps://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/\nhttps://medium.com/@elizarov/structured-concurrency-722d765aa952\nhttps://kotlinlang.org/docs/coroutines-basics.html\nhttps://github.com/golang/go/issues/29011\nhttps://github.com/arunsworld/nursery/blob/master/nursery.go\nhttps://arunsworld.medium.com/structured-concurrency-in-go-b800c7c4434e\nhttps://realpython.com/python311-exception-groups/\nhttps://zhuanlan.zhihu.com/p/108759542\nhttps://onevcat.com/2021/09/structured-concurrency/\nhttps://blog.softwaremill.com/structured-concurrency-and-pure-functions-92dd8ed1a9f2\n","wordCount":"1292","inLanguage":"en","datePublished":"2022-08-01T23:54:05+08:00","dateModified":"2022-08-01T23:54:05+08:00","author":{"@type":"Person","name":"zhoukuncheng"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/posts/structured-concurrency/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://zhoukuncheng.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zhoukuncheng.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoukuncheng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoukuncheng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoukuncheng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Structured Concurrency</h1><div class=post-meta><span title='2022-08-01 23:54:05 +0800 +0800'>August 1, 2022</span>&nbsp;·&nbsp;<span>zhoukuncheng</span>&nbsp;|&nbsp;<span>Translations:</span><ul class=i18n_list><li><a href=https://zhoukuncheng.github.io/zh/posts/structured-concurrency/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#definition aria-label=Definition>Definition</a><ul><li><a href=#structured-programming-vs-goto aria-label="Structured Programming vs goto">Structured Programming vs goto</a></li><li><a href=#illustrations aria-label=Illustrations>Illustrations</a></li></ul></li><li><a href=#background aria-label=Background>Background</a><ul><li><a href=#development-process aria-label="Development Process">Development Process</a></li></ul></li><li><a href=#example aria-label=Example>Example</a></li><li><a href=#proposals-in-go aria-label="Proposals in Go">Proposals in Go</a></li></ul></li><li><a href=#how-to-practice-structured-concurrency-in-go aria-label="How to Practice Structured Concurrency in Go">How to Practice Structured Concurrency in Go</a><ul><li><a href=#problems-to-consider-in-concurrent-programming aria-label="Problems to Consider in Concurrent Programming">Problems to Consider in Concurrent Programming</a></li><li><a href=#solutions-in-go aria-label="Solutions in Go">Solutions in Go</a><ul><ul><li><a href=#example-1-errgroup aria-label="Example 1: errgroup">Example 1: errgroup</a></li><li><a href=#errgroup-source-code-analysis aria-label="errgroup Source Code Analysis">errgroup Source Code Analysis</a></li><li><a href=#example-2-waitgroup aria-label="Example 2: waitGroup">Example 2: waitGroup</a></li></ul></ul></li></ul></li><li><a href=#references-and-citations aria-label="References and Citations">References and Citations</a></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><h2 id=definition>Definition<a hidden class=anchor aria-hidden=true href=#definition>#</a></h2><p>According to Wikipedia:<br><strong>Structured concurrency</strong> is a <a href=https://en.wikipedia.org/wiki/Programming_paradigm title="Programming paradigm">programming paradigm</a> aimed at improving the <strong>clarity, quality, and development time</strong> of a <a href=https://en.wikipedia.org/wiki/Computer_program title="Computer program">computer program</a> by using a structured approach to <a href=https://en.wikipedia.org/wiki/Concurrent_computing title="Concurrent computing">concurrent programming</a>.</p><p>The core concept is the <strong>encapsulation of concurrent threads of execution</strong> (here encompassing kernel and userland threads and processes) by way of control flow constructs that have <strong>clear entry and exit points</strong> and that ensure <strong>all spawned threads have completed before exit</strong>. Such encapsulation allows <strong>errors in concurrent threads to be propagated to the control structure&rsquo;s parent scope</strong> and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model <strong>must be applied consistently throughout all levels of the program</strong> – otherwise <strong>concurrent threads may leak out</strong>, become orphaned, or fail to have runtime errors correctly propagated.</p><p>Structured concurrency is analogous to <a href=https://en.wikipedia.org/wiki/Structured_programming title="Structured programming">structured programming</a>, which introduced control flow constructs that encapsulated sequential statements and subroutines.</p><p>In short: <strong>Structured Concurrency</strong> is a term similar to <strong>Structured Programming</strong>, aimed at improving the readability and controllability of concurrent programming, i.e., improving the development experience and the quality of concurrent code.<br>The basic concept is to encapsulate the execution of threads, ensuring they have clear entry and exit points, and that all threads complete before exiting.<br>The means of encapsulation also includes delegating errors generated in threads to the parent scope for handling.<br>Moreover, even with concurrency, the control flow structure remains clearly readable in the source code.</p><hr><h3 id=structured-programming-vs-goto>Structured Programming vs goto<a hidden class=anchor aria-hidden=true href=#structured-programming-vs-goto>#</a></h3><p>Structured Programming: Uses code blocks to encapsulate basic control flow, including common conditional statements, loops, and function calls.<br><img loading=lazy src=/static/Pastedimage20220731221808.png></p><p>goto: Unrestricted jumps.<br><img loading=lazy src=/static/Pastedimage20220731221638.png></p><hr><h3 id=illustrations>Illustrations<a hidden class=anchor aria-hidden=true href=#illustrations>#</a></h3><p><img loading=lazy src=/static/Pastedimage20220731222204.png><br><img loading=lazy src=/static/Pastedimage20220731223832.png></p><hr><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><h3 id=development-process>Development Process<a hidden class=anchor aria-hidden=true href=#development-process>#</a></h3><p>In 2016, ZeroMQ author Martin Sústrik formally proposed the concept of structured concurrency in his <a href=http://250bpm.com/blog:71>article</a>.<br>In 2018, Nathaniel J. Smith implemented this paradigm in Python - <a href=https://trio.readthedocs.io/en/stable/>trio</a>, and further elaborated on Structured Concurrency in the article <a href=https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/>Notes on structured concurrency, or: Go statement considered harmful</a>.<br>At the same time, Roman Elizarov also proposed the same <a href=https://elizarov.medium.com/structured-concurrency-722d765aa952>idea</a>, and implemented the well-known <a href=https://kotlinlang.org/docs/coroutines-basics.html>kotlinx.coroutine</a> in Kotlin.<br>In 2019, OpenJDK loom project also began introducing <a href=https://openjdk.org/jeps/428>structured concurrency</a> as part of its lightweight threads and coroutines. It will be included in Java 19.<br>In 2022, Python 3.11 introduced <a href=https://realpython.com/python311-exception-groups/>task group and exception group</a>, officially supporting structured concurrency.<br>Additionally, newer programming languages like Swift and Rust also have official or third-party libraries implementing Structured Concurrency.</p><hr><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>  
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>httpx</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>client</span> <span class=o>=</span> <span class=n>httpx</span><span class=o>.</span><span class=n>AsyncClient</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>run</span><span class=p>():</span>  
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=k>await</span> <span class=n>client</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;http://127.0.0.1:8000&#34;</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>text</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>  
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>with</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>timeout</span><span class=p>(</span><span class=mi>1</span><span class=p>):</span>  
</span></span><span class=line><span class=cl>        <span class=k>async</span> <span class=k>with</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>TaskGroup</span><span class=p>()</span> <span class=k>as</span> <span class=n>tg</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>):</span>  
</span></span><span class=line><span class=cl>                <span class=n>tg</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>run</span><span class=p>())</span>  
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;all tasks have completed now.&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Traceback (most recent call last):
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\PycharmProjects\demo\main.py&#34;, line 14, in main
</span></span><span class=line><span class=cl>    async with asyncio.TaskGroup() as tg:
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\taskgroups.py&#34;, line 121, in __aexit__
</span></span><span class=line><span class=cl>    raise propagate_cancellation_error
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\taskgroups.py&#34;, line 96, in __aexit__
</span></span><span class=line><span class=cl>    await self._on_completed_fut
</span></span><span class=line><span class=cl>asyncio.exceptions.CancelledError
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>During handling of the above exception, another exception occurred:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Traceback (most recent call last):
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\PycharmProjects\demo\main.py&#34;, line 20, in &lt;module&gt;
</span></span><span class=line><span class=cl>    asyncio.run(main())
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\runners.py&#34;, line 187, in run
</span></span><span class=line><span class=cl>    return runner.run(main)
</span></span><span class=line><span class=cl>           ^^^^^^^^^^^^^^^^
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\runners.py&#34;, line 120, in run
</span></span><span class=line><span class=cl>    return self._loop.run_until_complete(task)
</span></span><span class=line><span class=cl>           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\base_events.py&#34;, line 650, in run_until_complete
</span></span><span class=line><span class=cl>    return future.result()
</span></span><span class=line><span class=cl>           ^^^^^^^^^^^^^^^
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\PycharmProjects\demo\main.py&#34;, line 13, in main
</span></span><span class=line><span class=cl>    async with asyncio.timeout(1):
</span></span><span class=line><span class=cl>  File &#34;C:\Users\jack\.pyenv\pyenv-win\versions\3.11.0b4\Lib\asyncio\timeouts.py&#34;, line 98, in __aexit__
</span></span><span class=line><span class=cl>    raise TimeoutError
</span></span><span class=line><span class=cl>TimeoutError
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Process finished with exit code 1
</span></span></code></pre></div><hr><h2 id=proposals-in-go>Proposals in Go<a hidden class=anchor aria-hidden=true href=#proposals-in-go>#</a></h2><p>Someone proposed <a href=https://github.com/golang/go/issues/29011># proposal: Go 2: use structured concurrency #29011</a> to the official Go team. However, based on the opinions of Go community contributors like ianlancetaylor, this proposal might cause compatibility issues with existing Go code. Besides, the current Go standard library already has tools like <code>context.Context</code>, <code>sync.WaitGroup</code>, and <code>x/sync/errgroup</code>, so this proposal was ultimately not accepted.</p><hr><h1 id=how-to-practice-structured-concurrency-in-go>How to Practice Structured Concurrency in Go<a hidden class=anchor aria-hidden=true href=#how-to-practice-structured-concurrency-in-go>#</a></h1><h2 id=problems-to-consider-in-concurrent-programming>Problems to Consider in Concurrent Programming<a hidden class=anchor aria-hidden=true href=#problems-to-consider-in-concurrent-programming>#</a></h2><ul><li>When does this task <strong>start</strong>, and when does it <strong>end</strong>?</li><li>How to ensure the main task ends only after <strong>all subtasks have completed</strong>?</li><li>If a subtask fails, how does the main task <strong>cancel</strong> the remaining subtasks?</li><li>How to ensure all subtasks return within a specific <strong>timeout</strong>, whether they succeed or fail?</li><li>Furthermore, how to ensure the main task returns within a <strong>specified time</strong>, whether it succeeds or fails, while <strong>canceling</strong> all subtasks it spawned?</li><li>If the main task has ended but subtasks are still running, is there a resource leak?</li></ul><hr><h2 id=solutions-in-go>Solutions in Go<a hidden class=anchor aria-hidden=true href=#solutions-in-go>#</a></h2><ul><li>channel</li><li>context</li><li>waitgroup</li><li>errgroup</li></ul><h4 id=example-1-errgroup>Example 1: errgroup<a hidden class=anchor aria-hidden=true href=#example-1-errgroup>#</a></h4><p><a href=https://pkg.go.dev/golang.org/x/sync/errgroup>Link</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;context&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;crypto/md5&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;io/ioutil&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;log&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;os&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;path/filepath&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;golang.org/x/sync/errgroup&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Pipeline demonstrates the use of a Group to implement a multi-stage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// pipeline: a version of the MD5All function with bounded parallelism from</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// https://blog.golang.org/pipelines.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>MD5All</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;.&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>k</span><span class=p>,</span><span class=w> </span><span class=nx>sum</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>m</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s:\t%x\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>k</span><span class=p>,</span><span class=w> </span><span class=nx>sum</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>path</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sum</span><span class=w>  </span><span class=p>[</span><span class=nx>md5</span><span class=p>.</span><span class=nx>Size</span><span class=p>]</span><span class=kt>byte</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// MD5All reads all the files in the file tree rooted at root and returns a map</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// from file path to the MD5 sum of the file&#39;s contents. If the directory walk</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// fails or any read operation fails, MD5All returns an error.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>MD5All</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>root</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][</span><span class=nx>md5</span><span class=p>.</span><span class=nx>Size</span><span class=p>]</span><span class=kt>byte</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ctx is canceled when g.Wait() returns. When this version of MD5All returns</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// - even in case of error! - we know that all of the goroutines have finished</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// and the memory they were using can be garbage-collected.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>ctx</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>errgroup</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>paths</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>g</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>defer</span><span class=w> </span><span class=nb>close</span><span class=p>(</span><span class=nx>paths</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nx>filepath</span><span class=p>.</span><span class=nf>Walk</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>path</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>info</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nx>FileInfo</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>return</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>info</span><span class=p>.</span><span class=nf>Mode</span><span class=p>().</span><span class=nf>IsRegular</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>select</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>case</span><span class=w> </span><span class=nx>paths</span><span class=w> </span><span class=o>&lt;-</span><span class=w> </span><span class=nx>path</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>case</span><span class=w> </span><span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>return</span><span class=w> </span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Start a fixed number of goroutines to read and digest files.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=nx>result</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>const</span><span class=w> </span><span class=nx>numDigesters</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>20</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>numDigesters</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>g</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>for</span><span class=w> </span><span class=nx>path</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>paths</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=k>return</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>select</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>case</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=o>&lt;-</span><span class=w> </span><span class=nx>result</span><span class=p>{</span><span class=nx>path</span><span class=p>,</span><span class=w> </span><span class=nx>md5</span><span class=p>.</span><span class=nf>Sum</span><span class=p>(</span><span class=nx>data</span><span class=p>)}:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>case</span><span class=w> </span><span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=k>return</span><span class=w> </span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>g</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>close</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>m</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][</span><span class=nx>md5</span><span class=p>.</span><span class=nx>Size</span><span class=p>]</span><span class=kt>byte</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>m</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>path</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>r</span><span class=p>.</span><span class=nx>sum</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Check whether any of the goroutines failed. Since g is accumulating the</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// errors, we don&#39;t need to send them (or check for them) in the individual</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// results sent on the channel.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nf>Wait</span><span class=p>();</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=errgroup-source-code-analysis>errgroup Source Code Analysis<a hidden class=anchor aria-hidden=true href=#errgroup-source-code-analysis>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Group</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>cancel</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w>       </span><span class=c1>// Encapsulates context cancel method</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>wg</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=w>   </span><span class=c1>// Uses waitGroup for synchronization</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sem</span><span class=w> </span><span class=kd>chan</span><span class=w> </span><span class=nx>token</span><span class=w>      </span><span class=c1>// Uses channel to limit number</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>errOnce</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span><span class=w>   </span><span class=c1>// Ensures only executed once</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>err</span><span class=w>     </span><span class=kt>error</span><span class=w>       </span><span class=c1>// Stores execution error message</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Wait blocks until all function calls from the Go method have returned, then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// returns the first non-nil error (if any) from them.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>Wait</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>g</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>cancel</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>g</span><span class=p>.</span><span class=nf>cancel</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Go calls the given function in a new goroutine.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// It blocks until the new goroutine can be added without the number of</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// active goroutines in the group exceeding the configured limit.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// The first call to return a non-nil error cancels the group; its error will be</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// returned by Wait.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>Go</span><span class=p>(</span><span class=nx>f</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>sem</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>g</span><span class=p>.</span><span class=nx>sem</span><span class=w> </span><span class=o>&lt;-</span><span class=w> </span><span class=nx>token</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>g</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>defer</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nf>done</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>f</span><span class=p>();</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>g</span><span class=p>.</span><span class=nx>errOnce</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nx>g</span><span class=p>.</span><span class=nx>err</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>if</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>cancel</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=nx>g</span><span class=p>.</span><span class=nf>cancel</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=example-2-waitgroup>Example 2: waitGroup<a hidden class=anchor aria-hidden=true href=#example-2-waitgroup>#</a></h4><p><a href=https://github.com/arunsworld/nursery/blob/ecfe7a688cfd866de0da8ecff34de72b34d22f53/nursery.go>https://github.com/arunsworld/nursery/blob/ecfe7a688cfd866de0da8ecff34de72b34d22f53/nursery.go</a></p><hr><h1 id=references-and-citations>References and Citations<a hidden class=anchor aria-hidden=true href=#references-and-citations>#</a></h1><p><a href=https://en.wikipedia.org/wiki/Structured_concurrency>https://en.wikipedia.org/wiki/Structured_concurrency</a><br><a href=http://250bpm.com/blog:71>http://250bpm.com/blog:71</a><br><a href=https://trio.readthedocs.io/en/stable/>https://trio.readthedocs.io/en/stable/</a><br><a href=https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/>https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/</a><br><a href=https://medium.com/@elizarov/structured-concurrency-722d765aa952>https://medium.com/@elizarov/structured-concurrency-722d765aa952</a><br><a href=https://kotlinlang.org/docs/coroutines-basics.html>https://kotlinlang.org/docs/coroutines-basics.html</a><br><a href=https://github.com/golang/go/issues/29011>https://github.com/golang/go/issues/29011</a><br><a href=https://github.com/arunsworld/nursery/blob/master/nursery.go>https://github.com/arunsworld/nursery/blob/master/nursery.go</a><br><a href=https://arunsworld.medium.com/structured-concurrency-in-go-b800c7c4434e>https://arunsworld.medium.com/structured-concurrency-in-go-b800c7c4434e</a><br><a href=https://realpython.com/python311-exception-groups/>https://realpython.com/python311-exception-groups/</a><br><a href=https://zhuanlan.zhihu.com/p/108759542>https://zhuanlan.zhihu.com/p/108759542</a><br><a href=https://onevcat.com/2021/09/structured-concurrency/>https://onevcat.com/2021/09/structured-concurrency/</a><br><a href=https://blog.softwaremill.com/structured-concurrency-and-pure-functions-92dd8ed1a9f2>https://blog.softwaremill.com/structured-concurrency-and-pure-functions-92dd8ed1a9f2</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/tags/golang/>Golang</a></li><li><a href=https://zhoukuncheng.github.io/tags/concurrency/>Concurrency</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=purple_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://zhoukuncheng.github.io/>zhoukuncheng's Personal Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>