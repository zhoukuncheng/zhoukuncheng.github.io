<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT | zhoukuncheng's Personal Blog</title>
<meta name=keywords content="Golang,JavaScipt,HTTP"><meta name=description content="Introduction In the age of real-time interactivity where services like ChatGPT excel, it&rsquo;s crucial for developers to leverage technologies that allow for seamless data streaming in their applications. This article will delve into the world of HTML5 Server-Sent Events (SSE), a powerful tool akin to the technology behind conversational AI interfaces. Similar to how ChatGPT streams data to provide instant responses, SSE enables web browsers to receive updates from a server without the need for repetitive client-side requests. Whether you&rsquo;re building a chat application, a live notification system, or any service requiring real-time data flow, this guide will equip you with the knowledge to implement SSE efficiently in your applications, ensuring a responsive and engaging user experience.
Understanding Server-Sent Events (SSE) Server-Sent Events (SSE) is a web technology that facilitates the server&rsquo;s ability to send real-time updates to clients over an established HTTP connection. Clients can receive a continuous data stream or messages via the EventSource JavaScript API, which is incorporated in the HTML5 specification by WHATWG. The official media type for SSE is text/event-stream.
Here is an illustrative example of a typical SSE response:
event:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 Fields in SSE Messages Messages transmitted via SSE may contain the following fields:"><meta name=author content><link rel=canonical href=https://zhoukuncheng.github.io/posts/html5-sse/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/html5-sse/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT"><meta property="og:description" content="Introduction In the age of real-time interactivity where services like ChatGPT excel, it&rsquo;s crucial for developers to leverage technologies that allow for seamless data streaming in their applications. This article will delve into the world of HTML5 Server-Sent Events (SSE), a powerful tool akin to the technology behind conversational AI interfaces. Similar to how ChatGPT streams data to provide instant responses, SSE enables web browsers to receive updates from a server without the need for repetitive client-side requests. Whether you&rsquo;re building a chat application, a live notification system, or any service requiring real-time data flow, this guide will equip you with the knowledge to implement SSE efficiently in your applications, ensuring a responsive and engaging user experience.
Understanding Server-Sent Events (SSE) Server-Sent Events (SSE) is a web technology that facilitates the server&rsquo;s ability to send real-time updates to clients over an established HTTP connection. Clients can receive a continuous data stream or messages via the EventSource JavaScript API, which is incorporated in the HTML5 specification by WHATWG. The official media type for SSE is text/event-stream.
Here is an illustrative example of a typical SSE response:
event:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 Fields in SSE Messages Messages transmitted via SSE may contain the following fields:"><meta property="og:type" content="article"><meta property="og:url" content="https://zhoukuncheng.github.io/posts/html5-sse/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-30T23:11:34+08:00"><meta property="article:modified_time" content="2023-12-30T23:11:34+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT"><meta name=twitter:description content="Introduction In the age of real-time interactivity where services like ChatGPT excel, it&rsquo;s crucial for developers to leverage technologies that allow for seamless data streaming in their applications. This article will delve into the world of HTML5 Server-Sent Events (SSE), a powerful tool akin to the technology behind conversational AI interfaces. Similar to how ChatGPT streams data to provide instant responses, SSE enables web browsers to receive updates from a server without the need for repetitive client-side requests. Whether you&rsquo;re building a chat application, a live notification system, or any service requiring real-time data flow, this guide will equip you with the knowledge to implement SSE efficiently in your applications, ensuring a responsive and engaging user experience.
Understanding Server-Sent Events (SSE) Server-Sent Events (SSE) is a web technology that facilitates the server&rsquo;s ability to send real-time updates to clients over an established HTTP connection. Clients can receive a continuous data stream or messages via the EventSource JavaScript API, which is incorporated in the HTML5 specification by WHATWG. The official media type for SSE is text/event-stream.
Here is an illustrative example of a typical SSE response:
event:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 Fields in SSE Messages Messages transmitted via SSE may contain the following fields:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT","item":"https://zhoukuncheng.github.io/posts/html5-sse/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT","name":"Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT","description":"Introduction In the age of real-time interactivity where services like ChatGPT excel, it\u0026rsquo;s crucial for developers to leverage technologies that allow for seamless data streaming in their applications. This article will delve into the world of HTML5 Server-Sent Events (SSE), a powerful tool akin to the technology behind conversational AI interfaces. Similar to how ChatGPT streams data to provide instant responses, SSE enables web browsers to receive updates from a server without the need for repetitive client-side requests. Whether you\u0026rsquo;re building a chat application, a live notification system, or any service requiring real-time data flow, this guide will equip you with the knowledge to implement SSE efficiently in your applications, ensuring a responsive and engaging user experience.\nUnderstanding Server-Sent Events (SSE) Server-Sent Events (SSE) is a web technology that facilitates the server\u0026rsquo;s ability to send real-time updates to clients over an established HTTP connection. Clients can receive a continuous data stream or messages via the EventSource JavaScript API, which is incorporated in the HTML5 specification by WHATWG. The official media type for SSE is text/event-stream.\nHere is an illustrative example of a typical SSE response:\nevent:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 Fields in SSE Messages Messages transmitted via SSE may contain the following fields:","keywords":["Golang","JavaScipt","HTTP"],"articleBody":"Introduction In the age of real-time interactivity where services like ChatGPT excel, it’s crucial for developers to leverage technologies that allow for seamless data streaming in their applications. This article will delve into the world of HTML5 Server-Sent Events (SSE), a powerful tool akin to the technology behind conversational AI interfaces. Similar to how ChatGPT streams data to provide instant responses, SSE enables web browsers to receive updates from a server without the need for repetitive client-side requests. Whether you’re building a chat application, a live notification system, or any service requiring real-time data flow, this guide will equip you with the knowledge to implement SSE efficiently in your applications, ensuring a responsive and engaging user experience.\nUnderstanding Server-Sent Events (SSE) Server-Sent Events (SSE) is a web technology that facilitates the server’s ability to send real-time updates to clients over an established HTTP connection. Clients can receive a continuous data stream or messages via the EventSource JavaScript API, which is incorporated in the HTML5 specification by WHATWG. The official media type for SSE is text/event-stream.\nHere is an illustrative example of a typical SSE response:\nevent:message data:The Current Time Is 2023-12-30 23:00:21 event:message data:The Current Time Is 2023-12-30 23:00:31 event:message data:The Current Time Is 2023-12-30 23:00:41 event:message data:The Current Time Is 2023-12-30 23:00:51 Fields in SSE Messages Messages transmitted via SSE may contain the following fields:\nevent: A string specifying the event type. If designated, an event is dispatched in the browser to the corresponding event name listener. Use addEventListener() to listen for named events. The onmessage handler is invoked if no event name is specified.\ndata: This field contains the message content. If the EventSource receives multiple consecutive lines beginning with data:, it concatenates them, inserting a newline between each. Any trailing newlines are stripped.\nid: An identifier to set the EventSource object’s last event ID value.\nretry: The reconnection time in milliseconds. If the server connection drops, the browser will wait for this duration before attempting to reconnect. Non-integer values are disregarded.\nExample Implementation Let’s examine a simple example using the Go Gin SSE to demonstrate SSE functionality.\nClient-Side Code On the client side, only a minimal amount of HTML and JavaScript is necessary.\n\u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eServer Sent Event Example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"event-data\"\u003e\u003c/div\u003e \u003cscript\u003e // The EventSource object in JavaScript listens for streaming events from our Go server and displays the messages. const stream = new EventSource(\"/stream\"); stream.onmessage = function (e) { // Append the message data to the event-data div const eventDataElement = document.getElementById('event-data'); eventDataElement.innerHTML += e.data + \"\n\"; }; \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Explanation The EventSource object automatically establishes a connection to the server endpoint /stream, which should be set up to send continuous events. An event listener for the “message” event is added to the stream object to process incoming messages. The data from the event (e.data) is appended to the content of the event-data div, with each message on a new line. Server-Side Code The essential server logic, with Go channels, allows for the management of multiple clients.\n// Middleware to set the necessary headers for SSE func HeadersMiddleware() gin.HandlerFunc { return func(c *gin.Context) { c.Writer.Header().Set(\"Content-Type\", \"text/event-stream\") c.Writer.Header().Set(\"Cache-Control\", \"no-cache\") c.Writer.Header().Set(\"Connection\", \"keep-alive\") c.Writer.Header().Set(\"Transfer-Encoding\", \"chunked\") c.Next() } } // Endpoint to stream messages to the client authorized.GET(\"/stream\", HeadersMiddleware(), func(c *gin.Context) { clientChan, ok := c.Get(\"clientChan\") if !ok { return } c.Stream(func(w io.Writer) bool { if msg, ok := \u003c-clientChan; ok { c.SSEvent(\"message\", msg) return true } return false }) }) Let’s explore the SSEvent method in the Gin framework:\n// SSEvent writes a Server-Sent Event into the body stream. func (c *Context) SSEvent(name string, message any) { c.Render(-1, sse.Event{ Event: name, Data: message, }) } // Event struct for SSE type Event struct { Event string Id string Retry uint Data interface{} } Addressing Challenges While the client and server code for SSE appears straightforward, constructing a production-level SSE application introduces complexities. The JavaScript SSE API has certain limitations:\nOnly supports the GET method. Cannot send a request body. Does not allow custom headers, which can be crucial for passing authentication tokens. Limited control over retry strategy, with the browser attempting reconnection a few times before ceasing. Solutions for Enhanced Flexibility To overcome the constraints of the JavaScript EventSource API, consider utilizing third-party libraries such as fetch-event-source from Azure. This library leverages the Fetch API to manage server-sent events, offering greater control over request methods, headers, and bodies.\nExample usage of the fetch-event-source library:\n// Using the fetch-event-source library for more flexibility import { fetchEventSource } from '@microsoft/fetch-event-source'; const ctrl = new AbortController(); fetchEventSource('/api/sse', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer your-access-token' }, body: JSON.stringify({ foo: 'bar' }), signal: ctrl.signal, onmessage(ev) { console.log(ev.data); }, onopen(response) { // Handle the open event }, onerror(err) { // Handle errors }, onclose() { // Handle the close event } }); Conclusion While using SSE and the EventSource API for HTTP streaming is intuitive and straightforward, the limited customization options can hinder the development of comprehensive production applications. Employing third-party EventSource implementations can provide the necessary flexibility and control required for robust applications.\nReferences Server-Sent Events mdn docs Server-Sent Events Standard Using SSE with Gin ","wordCount":"862","inLanguage":"en","datePublished":"2023-12-30T23:11:34+08:00","dateModified":"2023-12-30T23:11:34+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/posts/html5-sse/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zhoukuncheng.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoukuncheng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoukuncheng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoukuncheng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT</h1><div class=post-meta><span title='2023-12-30 23:11:34 +0800 +0800'>December 30, 2023</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#understanding-server-sent-events-sse aria-label="Understanding Server-Sent Events (SSE)">Understanding Server-Sent Events (SSE)</a><ul><li><a href=#fields-in-sse-messages aria-label="Fields in SSE Messages">Fields in SSE Messages</a></li></ul></li><li><a href=#example-implementation aria-label="Example Implementation">Example Implementation</a><ul><li><a href=#client-side-code aria-label="Client-Side Code">Client-Side Code</a><ul><li><a href=#explanation aria-label=Explanation>Explanation</a></li></ul></li><li><a href=#server-side-code aria-label="Server-Side Code">Server-Side Code</a></li></ul></li></ul></li><li><a href=#addressing-challenges aria-label="Addressing Challenges">Addressing Challenges</a></li><li><a href=#solutions-for-enhanced-flexibility aria-label="Solutions for Enhanced Flexibility">Solutions for Enhanced Flexibility</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>In the age of real-time interactivity where services like ChatGPT excel, it&rsquo;s crucial for developers to leverage technologies that allow for seamless data streaming in their applications. This article will delve into the world of HTML5 Server-Sent Events (SSE), a powerful tool akin to the technology behind conversational AI interfaces. Similar to how ChatGPT streams data to provide instant responses, SSE enables web browsers to receive updates from a server without the need for repetitive client-side requests. Whether you&rsquo;re building a chat application, a live notification system, or any service requiring real-time data flow, this guide will equip you with the knowledge to implement SSE efficiently in your applications, ensuring a responsive and engaging user experience.</p><h2 id=understanding-server-sent-events-sse>Understanding Server-Sent Events (SSE)<a hidden class=anchor aria-hidden=true href=#understanding-server-sent-events-sse>#</a></h2><p>Server-Sent Events (SSE) is a web technology that facilitates the server&rsquo;s ability to send real-time updates to clients over an established HTTP connection. Clients can receive a continuous data stream or messages via the EventSource JavaScript API, which is incorporated in the HTML5 specification by WHATWG. The official media type for SSE is <code>text/event-stream</code>.</p><p>Here is an illustrative example of a typical SSE response:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:21
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:31
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:41
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event:message
</span></span><span class=line><span class=cl>data:The Current Time Is 2023-12-30 23:00:51
</span></span></code></pre></div><h3 id=fields-in-sse-messages>Fields in SSE Messages<a hidden class=anchor aria-hidden=true href=#fields-in-sse-messages>#</a></h3><p>Messages transmitted via SSE may contain the following fields:</p><ul><li><p><code>event</code>: A string specifying the event type. If designated, an event is dispatched in the browser to the corresponding event name listener. Use <code>addEventListener()</code> to listen for named events. The <code>onmessage</code> handler is invoked if no event name is specified.</p></li><li><p><code>data</code>: This field contains the message content. If the <code>EventSource</code> receives multiple consecutive lines beginning with <code>data:</code>, it concatenates them, inserting a newline between each. Any trailing newlines are stripped.</p></li><li><p><code>id</code>: An identifier to set the <code>EventSource</code> object&rsquo;s last event ID value.</p></li><li><p><code>retry</code>: The reconnection time in milliseconds. If the server connection drops, the browser will wait for this duration before attempting to reconnect. Non-integer values are disregarded.</p></li></ul><h2 id=example-implementation>Example Implementation<a hidden class=anchor aria-hidden=true href=#example-implementation>#</a></h2><p>Let&rsquo;s examine a simple example using the <a href=https://github.com/gin-gonic/examples/tree/master/server-sent-event>Go Gin SSE</a> to demonstrate SSE functionality.</p><h3 id=client-side-code>Client-Side Code<a hidden class=anchor aria-hidden=true href=#client-side-code>#</a></h3><p>On the client side, only a minimal amount of HTML and JavaScript is necessary.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=cp>&lt;!doctype html&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span> <span class=na>lang</span><span class=o>=</span><span class=s>&#34;en&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>charset</span><span class=o>=</span><span class=s>&#34;UTF-8&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>Server Sent Event Example<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>div</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;event-data&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The EventSource object in JavaScript listens for streaming events from our Go server and displays the messages.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>stream</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>EventSource</span><span class=p>(</span><span class=s2>&#34;/stream&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>stream</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Append the message data to the event-data div
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>const</span> <span class=nx>eventDataElement</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;event-data&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>eventDataElement</span><span class=p>.</span><span class=nx>innerHTML</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span> <span class=o>+</span> <span class=s2>&#34;&lt;br&gt;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=explanation>Explanation<a hidden class=anchor aria-hidden=true href=#explanation>#</a></h4><ul><li>The <code>EventSource</code> object automatically establishes a connection to the server endpoint <code>/stream</code>, which should be set up to send continuous events.</li><li>An event listener for the &ldquo;message&rdquo; event is added to the <code>stream</code> object to process incoming messages.</li><li>The data from the event (<code>e.data</code>) is appended to the content of the <code>event-data</code> div, with each message on a new line.</li></ul><h3 id=server-side-code>Server-Side Code<a hidden class=anchor aria-hidden=true href=#server-side-code>#</a></h3><p>The essential server logic, with Go channels, allows for the management of multiple clients.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Middleware to set the necessary headers for SSE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>HeadersMiddleware</span><span class=p>()</span> <span class=nx>gin</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Content-Type&#34;</span><span class=p>,</span> <span class=s>&#34;text/event-stream&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Cache-Control&#34;</span><span class=p>,</span> <span class=s>&#34;no-cache&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Connection&#34;</span><span class=p>,</span> <span class=s>&#34;keep-alive&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>Writer</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Transfer-Encoding&#34;</span><span class=p>,</span> <span class=s>&#34;chunked&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Endpoint to stream messages to the client
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>authorized</span><span class=p>.</span><span class=nf>GET</span><span class=p>(</span><span class=s>&#34;/stream&#34;</span><span class=p>,</span> <span class=nf>HeadersMiddleware</span><span class=p>(),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>clientChan</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;clientChan&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nf>Stream</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>msg</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>clientChan</span><span class=p>;</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>c</span><span class=p>.</span><span class=nf>SSEvent</span><span class=p>(</span><span class=s>&#34;message&#34;</span><span class=p>,</span> <span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>Let&rsquo;s explore the <code>SSEvent</code> method in the Gin framework:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// SSEvent writes a Server-Sent Event into the body stream.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Context</span><span class=p>)</span> <span class=nf>SSEvent</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>message</span> <span class=nx>any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nf>Render</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>sse</span><span class=p>.</span><span class=nx>Event</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Event</span><span class=p>:</span> <span class=nx>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Data</span><span class=p>:</span>  <span class=nx>message</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Event struct for SSE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Event</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Event</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Id</span>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Retry</span> <span class=kt>uint</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span>  <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=addressing-challenges>Addressing Challenges<a hidden class=anchor aria-hidden=true href=#addressing-challenges>#</a></h1><p>While the client and server code for SSE appears straightforward, constructing a production-level SSE application introduces complexities. The JavaScript SSE API has certain limitations:</p><ul><li>Only supports the GET method.</li><li>Cannot send a request body.</li><li>Does not allow custom headers, which can be crucial for passing authentication tokens.</li><li>Limited control over retry strategy, with the browser attempting reconnection a few times before ceasing.</li></ul><h1 id=solutions-for-enhanced-flexibility>Solutions for Enhanced Flexibility<a hidden class=anchor aria-hidden=true href=#solutions-for-enhanced-flexibility>#</a></h1><p>To overcome the constraints of the JavaScript EventSource API, consider utilizing third-party libraries such as <a href=https://github.com/Azure/fetch-event-source>fetch-event-source</a> from Azure. This library leverages the Fetch API to manage server-sent events, offering greater control over request methods, headers, and bodies.</p><p>Example usage of the <code>fetch-event-source</code> library:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Using the fetch-event-source library for more flexibility
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>fetchEventSource</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;@microsoft/fetch-event-source&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ctrl</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>AbortController</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fetchEventSource</span><span class=p>(</span><span class=s1>&#39;/api/sse&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>method</span><span class=o>:</span> <span class=s1>&#39;POST&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>headers</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Content-Type&#39;</span><span class=o>:</span> <span class=s1>&#39;application/json&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Authorization&#39;</span><span class=o>:</span> <span class=s1>&#39;Bearer your-access-token&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>body</span><span class=o>:</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span> <span class=nx>foo</span><span class=o>:</span> <span class=s1>&#39;bar&#39;</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>    <span class=nx>signal</span><span class=o>:</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nx>signal</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>onmessage</span><span class=p>(</span><span class=nx>ev</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>ev</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>onopen</span><span class=p>(</span><span class=nx>response</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Handle the open event
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>onerror</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Handle errors
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>onclose</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Handle the close event
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>While using SSE and the EventSource API for HTTP streaming is intuitive and straightforward, the limited customization options can hinder the development of comprehensive production applications. Employing third-party EventSource implementations can provide the necessary flexibility and control required for robust applications.</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events>Server-Sent Events mdn docs</a></li><li><a href=https://html.spec.whatwg.org/multipage/server-sent-events.html>Server-Sent Events Standard</a></li><li><a href=https://github.com/gin-gonic/examples/tree/master/server-sent-event>Using SSE with Gin</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/tags/golang/>Golang</a></li><li><a href=https://zhoukuncheng.github.io/tags/javascipt/>JavaScipt</a></li><li><a href=https://zhoukuncheng.github.io/tags/http/>HTTP</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=transparent_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zhoukuncheng.github.io/>zhoukuncheng's Personal Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>