<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency Pattern Differences between Python and Go | zhoukuncheng's Personal Blog</title><meta name=keywords content="Python,Golang,Concurrency"><meta name=description content="Concurrency in Python
In Python, early concurrency methods were dominated by traditional multi-processing and multi-threading, similar to Java. At the same time, there were many third-party asynchronous solutions (gevent/tornado/twisted, etc.).
In the Python 3 era, the official asyncio library and async/await syntax were introduced as Python&rsquo;s official coroutine implementation, which gradually became popular.
Processes
Example of multi-processing programming:
from multiprocessing import Process

def f(name):
    print('hello', name)

if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()
The API of multiprocessing is close to threading, making it relatively easy to create multi-process programs. It is a solution recommended by Python officially to bypass the GIL restriction of multi-threading.
However, it should be noted that the parameters for creating a process need to be pickle-serializable. It is best to use process-safe data structures like Pipe and Queue (Official Programming guidelines)."><meta name=author content="zhoukuncheng"><link rel=canonical href=https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://zhoukuncheng.github.io/zh/posts/concurrency-model-differences-between-python-go/><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GH88YSLNJN"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GH88YSLNJN")}</script><meta property="og:url" content="https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/"><meta property="og:site_name" content="zhoukuncheng's Personal Blog"><meta property="og:title" content="Concurrency Pattern Differences between Python and Go"><meta property="og:description" content="Concurrency in Python In Python, early concurrency methods were dominated by traditional multi-processing and multi-threading, similar to Java. At the same time, there were many third-party asynchronous solutions (gevent/tornado/twisted, etc.).
In the Python 3 era, the official asyncio library and async/await syntax were introduced as Python’s official coroutine implementation, which gradually became popular.
Processes Example of multi-processing programming:
from multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() The API of multiprocessing is close to threading, making it relatively easy to create multi-process programs. It is a solution recommended by Python officially to bypass the GIL restriction of multi-threading.
However, it should be noted that the parameters for creating a process need to be pickle-serializable. It is best to use process-safe data structures like Pipe and Queue (Official Programming guidelines)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-30T23:54:05+08:00"><meta property="article:modified_time" content="2021-08-30T23:54:05+08:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Concurrency"><meta name=twitter:card content="summary"><meta name=twitter:title content="Concurrency Pattern Differences between Python and Go"><meta name=twitter:description content="Concurrency in Python
In Python, early concurrency methods were dominated by traditional multi-processing and multi-threading, similar to Java. At the same time, there were many third-party asynchronous solutions (gevent/tornado/twisted, etc.).
In the Python 3 era, the official asyncio library and async/await syntax were introduced as Python&rsquo;s official coroutine implementation, which gradually became popular.
Processes
Example of multi-processing programming:
from multiprocessing import Process

def f(name):
    print('hello', name)

if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()
The API of multiprocessing is close to threading, making it relatively easy to create multi-process programs. It is a solution recommended by Python officially to bypass the GIL restriction of multi-threading.
However, it should be noted that the parameters for creating a process need to be pickle-serializable. It is best to use process-safe data structures like Pipe and Queue (Official Programming guidelines)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Concurrency Pattern Differences between Python and Go","item":"https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Concurrency Pattern Differences between Python and Go","name":"Concurrency Pattern Differences between Python and Go","description":"Concurrency in Python In Python, early concurrency methods were dominated by traditional multi-processing and multi-threading, similar to Java. At the same time, there were many third-party asynchronous solutions (gevent/tornado/twisted, etc.).\nIn the Python 3 era, the official asyncio library and async/await syntax were introduced as Python\u0026rsquo;s official coroutine implementation, which gradually became popular.\nProcesses Example of multi-processing programming:\nfrom multiprocessing import Process def f(name): print(\u0026#39;hello\u0026#39;, name) if __name__ == \u0026#39;__main__\u0026#39;: p = Process(target=f, args=(\u0026#39;bob\u0026#39;,)) p.start() p.join() The API of multiprocessing is close to threading, making it relatively easy to create multi-process programs. It is a solution recommended by Python officially to bypass the GIL restriction of multi-threading.\nHowever, it should be noted that the parameters for creating a process need to be pickle-serializable. It is best to use process-safe data structures like Pipe and Queue (Official Programming guidelines).\n","keywords":["Python","Golang","Concurrency"],"articleBody":"Concurrency in Python In Python, early concurrency methods were dominated by traditional multi-processing and multi-threading, similar to Java. At the same time, there were many third-party asynchronous solutions (gevent/tornado/twisted, etc.).\nIn the Python 3 era, the official asyncio library and async/await syntax were introduced as Python’s official coroutine implementation, which gradually became popular.\nProcesses Example of multi-processing programming:\nfrom multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() The API of multiprocessing is close to threading, making it relatively easy to create multi-process programs. It is a solution recommended by Python officially to bypass the GIL restriction of multi-threading.\nHowever, it should be noted that the parameters for creating a process need to be pickle-serializable. It is best to use process-safe data structures like Pipe and Queue (Official Programming guidelines).\nThreads Example of multi-threading code:\nfrom threading import Thread def f(name): print('hello', name) if __name__ == '__main__': p = Thread(target=f, args=('bob',)) p.start() p.join() # Thread pool approach with ThreadPoolExecutor(max_workers=1) as executor: future = executor.submit(pow, 323, 1235) print(future.result()) Drawback of CPython Threads: GIL (Global Interpreter Lock)\nThe GIL is a global lock used by CPython when executing Python bytecodes, preventing the interpreter from fully utilizing multi-cores for CPU-bound tasks, while IO-bound tasks release the GIL.\nTo bypass the GIL, one must switch to multi-processing or use C extensions.\nCoroutines asyncio example:\nimport asyncio import time async def say_after(delay, what): await asyncio.sleep(delay) print(what) async def main(): print(f\"started at {time.strftime('%X')}\") await asyncio.gather(say_after(1, 'hello'), say_after(2,'world')) print(f\"finished at {time.strftime('%X')}\") asyncio.run(main()) # started at 22:32:23 # hello # world # finished at 22:32:25 async syntax and asyncio Starting from version 3.4, Python’s standard library includes the asyncio module, and from 3.5 onwards, it supports async/await syntax.\nThe implementation of Python coroutines can be traced back to the yield keyword and the generator structure introduced in the Python 2 era:\nGenerators pause via yield and can return values. The caller resumes the generator via next() or send() methods, and can send data to the generator via send(). The yield from syntactic sugar facilitates iterating over every value in a generator. With the introduction of async/await syntax, the coroutine type was officially established. The asyncio library provides an official event loop implementation and supports IO multiplexing on different operating systems (select/epoll/iocp, etc.), or can be replaced by third-party implementations (like uvloop) via configuration. With the help of the concurrent.futures thread pool/process pool module, it supports multi-threading/multi-processing, but the event loop itself remains single-threaded. Concurrency in Go goroutine and channel example:\npackage main import \"fmt\" func main() { messages := make(chan string) go func() { messages \u003c- \"ping\" }() msg := \u003c-messages fmt.Println(msg) } goroutine and channel Golang implements user-space coroutines called goroutines, scheduling them via the GPM model.\nIt also supports network IO multiplexing via netpoller.\nCommunication between different goroutines is achieved through channels.\nCSP CSP (Communicating Sequential Processes) is a concurrency model that interacts via message passing rather than shared variables.\nComparison Stackful vs Stackless Coroutines Single-threaded vs Multi-threaded ","wordCount":"500","inLanguage":"en","datePublished":"2021-08-30T23:54:05+08:00","dateModified":"2021-08-30T23:54:05+08:00","author":{"@type":"Person","name":"zhoukuncheng"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://zhoukuncheng.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zhoukuncheng.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoukuncheng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoukuncheng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoukuncheng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Concurrency Pattern Differences between Python and Go</h1><div class=post-meta><span title='2021-08-30 23:54:05 +0800 +0800'>August 30, 2021</span>&nbsp;·&nbsp;<span>zhoukuncheng</span>&nbsp;|&nbsp;<span>Translations:</span><ul class=i18n_list><li><a href=https://zhoukuncheng.github.io/zh/posts/concurrency-model-differences-between-python-go/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#concurrency-in-python aria-label="Concurrency in Python">Concurrency in Python</a><ul><li><a href=#processes aria-label=Processes>Processes</a></li><li><a href=#threads aria-label=Threads>Threads</a></li><li><a href=#coroutines aria-label=Coroutines>Coroutines</a><ul><li><a href=#async-syntax-and-asyncio aria-label="async syntax and asyncio">async syntax and asyncio</a></li></ul></li></ul></li><li><a href=#concurrency-in-go aria-label="Concurrency in Go">Concurrency in Go</a><ul><ul><li><a href=#goroutine-and-channel aria-label="goroutine and channel">goroutine and channel</a><ul><li><a href=#csp aria-label=CSP>CSP</a></li></ul></li></ul></ul></li><li><a href=#comparison aria-label=Comparison>Comparison</a><ul><li><a href=#stackful-vs-stackless-coroutines aria-label="Stackful vs Stackless Coroutines">Stackful vs Stackless Coroutines</a></li><li><a href=#single-threaded-vs-multi-threaded aria-label="Single-threaded vs Multi-threaded">Single-threaded vs Multi-threaded</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=concurrency-in-python>Concurrency in Python<a hidden class=anchor aria-hidden=true href=#concurrency-in-python>#</a></h2><p>In Python, early concurrency methods were dominated by traditional multi-processing and multi-threading, similar to Java. At the same time, there were many third-party asynchronous solutions (gevent/tornado/twisted, etc.).<br>In the Python 3 era, the official <code>asyncio</code> library and <code>async/await</code> syntax were introduced as Python&rsquo;s official coroutine implementation, which gradually became popular.</p><h3 id=processes>Processes<a hidden class=anchor aria-hidden=true href=#processes>#</a></h3><p>Example of multi-processing programming:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>multiprocessing</span> <span class=kn>import</span> <span class=n>Process</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Process</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=s1>&#39;bob&#39;</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></div><p>The API of <code>multiprocessing</code> is close to <code>threading</code>, making it relatively easy to create multi-process programs. It is a solution recommended by Python officially to bypass the GIL restriction of multi-threading.<br>However, it should be noted that the parameters for creating a process need to be pickle-serializable. It is best to use process-safe data structures like Pipe and Queue (<a href=https://docs.python.org/3/library/multiprocessing.html#programming-guidelines>Official Programming guidelines</a>).</p><h3 id=threads>Threads<a hidden class=anchor aria-hidden=true href=#threads>#</a></h3><p>Example of multi-threading code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>threading</span> <span class=kn>import</span> <span class=n>Thread</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=s1>&#39;bob&#39;</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Thread pool approach</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=n>max_workers</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=k>as</span> <span class=n>executor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>future</span> <span class=o>=</span> <span class=n>executor</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span><span class=nb>pow</span><span class=p>,</span> <span class=mi>323</span><span class=p>,</span> <span class=mi>1235</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>future</span><span class=o>.</span><span class=n>result</span><span class=p>())</span>
</span></span></code></pre></div><p><strong>Drawback of CPython Threads: GIL (Global Interpreter Lock)</strong><br>The GIL is a global lock used by CPython when executing Python bytecodes, preventing the interpreter from fully utilizing multi-cores for CPU-bound tasks, while IO-bound tasks release the GIL.<br>To bypass the GIL, one must switch to multi-processing or use C extensions.</p><h3 id=coroutines>Coroutines<a hidden class=anchor aria-hidden=true href=#coroutines>#</a></h3><p><code>asyncio</code> example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>say_after</span><span class=p>(</span><span class=n>delay</span><span class=p>,</span> <span class=n>what</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>delay</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>what</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;started at </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>strftime</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%X</span><span class=s1>&#39;</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=n>say_after</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;hello&#39;</span><span class=p>),</span> <span class=n>say_after</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;world&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;finished at </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>strftime</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%X</span><span class=s1>&#39;</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=c1># started at 22:32:23</span>
</span></span><span class=line><span class=cl><span class=c1># hello</span>
</span></span><span class=line><span class=cl><span class=c1># world</span>
</span></span><span class=line><span class=cl><span class=c1># finished at 22:32:25</span>
</span></span></code></pre></div><h4 id=async-syntax-and-asyncio><code>async</code> syntax and <code>asyncio</code><a hidden class=anchor aria-hidden=true href=#async-syntax-and-asyncio>#</a></h4><p>Starting from version 3.4, Python&rsquo;s standard library includes the <code>asyncio</code> module, and from 3.5 onwards, it supports <code>async/await</code> syntax.<br>The implementation of Python coroutines can be traced back to the <code>yield</code> keyword and the generator structure introduced in the Python 2 era:</p><ul><li>Generators pause via <code>yield</code> and can return values.</li><li>The caller resumes the generator via <code>next()</code> or <code>send()</code> methods, and can send data to the generator via <code>send()</code>.</li><li>The <code>yield from</code> syntactic sugar facilitates iterating over every value in a generator.</li><li>With the introduction of <code>async/await</code> syntax, the coroutine type was officially established.</li><li>The <code>asyncio</code> library provides an official event loop implementation and supports IO multiplexing on different operating systems (select/epoll/iocp, etc.), or can be replaced by third-party implementations (like uvloop) via configuration.</li><li>With the help of the <code>concurrent.futures</code> thread pool/process pool module, it supports multi-threading/multi-processing, but the event loop itself remains single-threaded.</li></ul><h2 id=concurrency-in-go>Concurrency in Go<a hidden class=anchor aria-hidden=true href=#concurrency-in-go>#</a></h2><p><code>goroutine</code> and <code>channel</code> example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=nx>messages</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>messages</span><span class=w> </span><span class=o>&lt;-</span><span class=w> </span><span class=s>&#34;ping&#34;</span><span class=w> </span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=nx>msg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&lt;-</span><span class=nx>messages</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=goroutine-and-channel>goroutine and channel<a hidden class=anchor aria-hidden=true href=#goroutine-and-channel>#</a></h4><p>Golang implements user-space coroutines called goroutines, scheduling them via the <a href=https://golang.org/src/runtime/runtime2.go>GPM model</a>.</p><p><img loading=lazy src=https://miro.medium.com/max/1302/1*2o9fS2rEJltFYom65wAIyw.jpeg></p><p>It also supports network IO multiplexing via <code>netpoller</code>.<br>Communication between different goroutines is achieved through channels.</p><h5 id=csp>CSP<a hidden class=anchor aria-hidden=true href=#csp>#</a></h5><p><a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>CSP (Communicating Sequential Processes)</a> is a concurrency model that interacts via message passing rather than shared variables.</p><h2 id=comparison>Comparison<a hidden class=anchor aria-hidden=true href=#comparison>#</a></h2><h3 id=stackful-vs-stackless-coroutines>Stackful vs Stackless Coroutines<a hidden class=anchor aria-hidden=true href=#stackful-vs-stackless-coroutines>#</a></h3><h3 id=single-threaded-vs-multi-threaded>Single-threaded vs Multi-threaded<a hidden class=anchor aria-hidden=true href=#single-threaded-vs-multi-threaded>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/tags/python/>Python</a></li><li><a href=https://zhoukuncheng.github.io/tags/golang/>Golang</a></li><li><a href=https://zhoukuncheng.github.io/tags/concurrency/>Concurrency</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=purple_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://zhoukuncheng.github.io/>zhoukuncheng's Personal Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>