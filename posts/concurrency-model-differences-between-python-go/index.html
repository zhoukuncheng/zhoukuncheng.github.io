<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 与 Go 之间的并发模式差异 | zhoukuncheng's Personal Blog</title>
<meta name=keywords content="Python,Golang,Concurrency"><meta name=description content="Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。 进程 多进程编程示例： from multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。 但需要注意，创建进程的参数"><meta name=author content><link rel=canonical href=https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zhoukuncheng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoukuncheng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoukuncheng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoukuncheng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoukuncheng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-GH88YSLNJN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GH88YSLNJN")}</script><meta property="og:title" content="Python 与 Go 之间的并发模式差异"><meta property="og:description" content="Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。 进程 多进程编程示例： from multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。 但需要注意，创建进程的参数"><meta property="og:type" content="article"><meta property="og:url" content="https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-30T23:54:05+08:00"><meta property="article:modified_time" content="2021-08-30T23:54:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 与 Go 之间的并发模式差异"><meta name=twitter:description content="Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。 进程 多进程编程示例： from multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。 但需要注意，创建进程的参数"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoukuncheng.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python 与 Go 之间的并发模式差异","item":"https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 与 Go 之间的并发模式差异","name":"Python 与 Go 之间的并发模式差异","description":"Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。 进程 多进程编程示例： from multiprocessing import Process def f(name): print(\u0026#39;hello\u0026#39;, name) if __name__ == \u0026#39;__main__\u0026#39;: p = Process(target=f, args=(\u0026#39;bob\u0026#39;,)) p.start() p.join() multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。 但需要注意，创建进程的参数","keywords":["Python","Golang","Concurrency"],"articleBody":"Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。\n在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。\n进程 多进程编程示例：\nfrom multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。\n但需要注意，创建进程的参数需要能被 pickle 序列化，最好使用 Pipe、Queue 等进程安全的数据结构（官方文档的 Programming guidelines）\n线程 多线程代码示例：\nfrom threading import Thread def f(name): print('hello', name) if __name__ == '__main__': p = Thread(target=f, args=('bob',)) p.start() p.join() # 线程池方式 with ThreadPoolExecutor(max_workers=1) as executor: future = executor.submit(pow, 323, 1235) print(future.result()) Cpython 线程的缺陷：GIL（全局解释器锁）\nGIL 是 Cpython 执行 Python 字节码时的一把全局锁，导致解释器在 CPU 密集型任务时不能充分利用多核，而 IO 密集型任务会释放 GIL。 如果想绕过 GIL，只能换成多进程方式，或者通过C 扩展绕过。\n协程 asyncio示例：\nimport asyncio import time async def say_after(delay, what): await asyncio.sleep(delay) print(what) async def main(): print(f\"started at {time.strftime('%X')}\") await asyncio.gather(say_after(1, 'hello'), say_after(2,'world')) print(f\"finished at {time.strftime('%X')}\") asyncio.run(main()) # started at 22:32:23 # hello # world # finished at 22:32:25 async 语法 与 asyncio Python 从 3.4 版本开始，标准库自带 asyncio 模块，并从 3.5 开始，支持 async/await 语法。\nPython 协程的实现可以追溯到 Python 2 时期引入的 yield 关键字和生成器这种特殊结构：\n生成器通过 yield 暂停，并且可以返回值 调用方通过 next() 或者 send() 方法恢复生成器的运行，并且可以通过 send() 发送数据给生成器 yield from 语法糖可以方便的迭代生成器中每一个值 通过引入 async/await 语法，正式确立协程类型 asyncio 库提供了官方的事件循环实现，并且支持不同操作系统的 io 多路复用（select/epoll/iocp 等），或者可以通过配置替换为第三方实现（如 uvloop） 借助 concurrent.futures 线程池/进程池 模块，支持多线程/多进程，但事件循环本身依旧是单线程模式 Go 并发方式 goroutine 与 channel 示例：\npackage main import \"fmt\" func main() { messages := make(chan string) go func() { messages \u003c- \"ping\" }() msg := \u003c-messages fmt.Println(msg) } goroutine 与 channel Golang 实现了用户态的协程 goroutine，通过GPM模型来进行协程的调度， 并且通过 netpoller 来支持网络的IO多路复用；\n通过 channel 在不同 goroutine 中进行通信。\nCSP CSP（通信顺序进程）是一种并发的模型，通过消息传递来进行交互，而不是通过共享变量。\n对比 有栈协程与无栈协程 单线程与多线程 ","wordCount":"878","inLanguage":"en","datePublished":"2021-08-30T23:54:05+08:00","dateModified":"2021-08-30T23:54:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/"},"publisher":{"@type":"Organization","name":"zhoukuncheng's Personal Blog","logo":{"@type":"ImageObject","url":"https://zhoukuncheng.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zhoukuncheng.github.io/ accesskey=h title="zhoukuncheng's Personal Blog (Alt + H)">zhoukuncheng's Personal Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://zhoukuncheng.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zhoukuncheng.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoukuncheng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoukuncheng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoukuncheng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python 与 Go 之间的并发模式差异</h1><div class=post-meta><span title='2021-08-30 23:54:05 +0800 +0800'>August 30, 2021</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python%e5%b9%b6%e5%8f%91%e6%96%b9%e5%bc%8f aria-label=Python并发方式>Python并发方式</a><ul><li><a href=#%e8%bf%9b%e7%a8%8b aria-label=进程>进程</a></li><li><a href=#%e7%ba%bf%e7%a8%8b aria-label=线程>线程</a></li><li><a href=#%e5%8d%8f%e7%a8%8b aria-label=协程>协程</a><ul><li><a href=#async-%e8%af%ad%e6%b3%95-%e4%b8%8e-asyncio aria-label="async 语法 与 asyncio">async 语法 与 asyncio</a></li></ul></li></ul></li><li><a href=#go-%e5%b9%b6%e5%8f%91%e6%96%b9%e5%bc%8f aria-label="Go 并发方式">Go 并发方式</a><ul><ul><li><a href=#goroutine-%e4%b8%8e-channel aria-label="goroutine 与 channel">goroutine 与 channel</a><ul><li><a href=#csp aria-label=CSP>CSP</a></li></ul></li></ul></ul></li><li><a href=#%e5%af%b9%e6%af%94 aria-label=对比>对比</a><ul><li><a href=#%e6%9c%89%e6%a0%88%e5%8d%8f%e7%a8%8b%e4%b8%8e%e6%97%a0%e6%a0%88%e5%8d%8f%e7%a8%8b aria-label=有栈协程与无栈协程>有栈协程与无栈协程</a></li><li><a href=#%e5%8d%95%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=单线程与多线程>单线程与多线程</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=python并发方式>Python并发方式<a hidden class=anchor aria-hidden=true href=#python并发方式>#</a></h2><p>在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。<br>在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。</p><h3 id=进程>进程<a hidden class=anchor aria-hidden=true href=#进程>#</a></h3><p>多进程编程示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>multiprocessing</span> <span class=kn>import</span> <span class=n>Process</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Process</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=s1>&#39;bob&#39;</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></div><p>multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。<br>但需要注意，创建进程的参数需要能被 pickle 序列化，最好使用 Pipe、Queue 等进程安全的数据结构（<a href=https://docs.python.org/3/library/multiprocessing.html#programming-guidelines>官方文档的 Programming guidelines</a>）</p><h3 id=线程>线程<a hidden class=anchor aria-hidden=true href=#线程>#</a></h3><p>多线程代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>threading</span> <span class=kn>import</span> <span class=n>Thread</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=s1>&#39;bob&#39;</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 线程池方式</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=n>max_workers</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=k>as</span> <span class=n>executor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>future</span> <span class=o>=</span> <span class=n>executor</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span><span class=nb>pow</span><span class=p>,</span> <span class=mi>323</span><span class=p>,</span> <span class=mi>1235</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>future</span><span class=o>.</span><span class=n>result</span><span class=p>())</span>
</span></span></code></pre></div><p>Cpython 线程的缺陷：GIL（全局解释器锁）<br>GIL 是 Cpython 执行 Python 字节码时的一把全局锁，导致解释器在 CPU 密集型任务时不能充分利用多核，而 IO 密集型任务会释放 GIL。<br>如果想绕过 GIL，只能换成多进程方式，或者通过C 扩展绕过。</p><h3 id=协程>协程<a hidden class=anchor aria-hidden=true href=#协程>#</a></h3><p>asyncio示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>say_after</span><span class=p>(</span><span class=n>delay</span><span class=p>,</span> <span class=n>what</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>delay</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>what</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;started at </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>strftime</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%X</span><span class=s1>&#39;</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=n>say_after</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;hello&#39;</span><span class=p>),</span> <span class=n>say_after</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;world&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;finished at </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>strftime</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%X</span><span class=s1>&#39;</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=c1># started at 22:32:23</span>
</span></span><span class=line><span class=cl><span class=c1># hello</span>
</span></span><span class=line><span class=cl><span class=c1># world</span>
</span></span><span class=line><span class=cl><span class=c1># finished at 22:32:25</span>
</span></span></code></pre></div><h4 id=async-语法-与-asyncio>async 语法 与 asyncio<a hidden class=anchor aria-hidden=true href=#async-语法-与-asyncio>#</a></h4><p>Python 从 3.4 版本开始，标准库自带 asyncio 模块，并从 3.5 开始，支持 async/await 语法。<br>Python 协程的实现可以追溯到 Python 2 时期引入的 yield 关键字和生成器这种特殊结构：</p><ul><li>生成器通过 yield 暂停，并且可以返回值</li><li>调用方通过 next() 或者 send() 方法恢复生成器的运行，并且可以通过 send() 发送数据给生成器</li><li>yield from 语法糖可以方便的迭代生成器中每一个值</li><li>通过引入 async/await 语法，正式确立协程类型</li><li>asyncio 库提供了官方的事件循环实现，并且支持不同操作系统的 io 多路复用（select/epoll/iocp 等），或者可以通过配置替换为第三方实现（如 uvloop）</li><li>借助 concurrent.futures 线程池/进程池 模块，支持多线程/多进程，但事件循环本身依旧是单线程模式</li></ul><h2 id=go-并发方式>Go 并发方式<a hidden class=anchor aria-hidden=true href=#go-并发方式>#</a></h2><p>goroutine 与 channel 示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>messages</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>messages</span> <span class=o>&lt;-</span> <span class=s>&#34;ping&#34;</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>   <span class=nx>msg</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>messages</span>
</span></span><span class=line><span class=cl>   <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=goroutine-与-channel>goroutine 与 channel<a hidden class=anchor aria-hidden=true href=#goroutine-与-channel>#</a></h4><p>Golang 实现了用户态的协程 goroutine，通过<a href=https://golang.org/src/runtime/runtime2.go>GPM模型</a>来进行协程的调度，
<img loading=lazy src=https://miro.medium.com/max/1302/1*2o9fS2rEJltFYom65wAIyw.jpeg alt><br>并且通过 netpoller 来支持网络的IO多路复用；<br>通过 channel 在不同 goroutine 中进行通信。</p><h5 id=csp>CSP<a hidden class=anchor aria-hidden=true href=#csp>#</a></h5><p><a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>CSP（通信顺序进程）</a>是一种并发的模型，通过消息传递来进行交互，而不是通过共享变量。</p><h2 id=对比>对比<a hidden class=anchor aria-hidden=true href=#对比>#</a></h2><h3 id=有栈协程与无栈协程>有栈协程与无栈协程<a hidden class=anchor aria-hidden=true href=#有栈协程与无栈协程>#</a></h3><h3 id=单线程与多线程>单线程与多线程<a hidden class=anchor aria-hidden=true href=#单线程与多线程>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoukuncheng.github.io/tags/python/>Python</a></li><li><a href=https://zhoukuncheng.github.io/tags/golang/>Golang</a></li><li><a href=https://zhoukuncheng.github.io/tags/concurrency/>Concurrency</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=zhoukuncheng/zhoukuncheng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODIxMTA1OTU=" data-category=General data-category-id=DIC_kwDOENCqg84Cexta data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=purple_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zhoukuncheng.github.io/>zhoukuncheng's Personal Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>